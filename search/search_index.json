{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Codellm-Devkit (aka. CLDK) is a multilingual program analysis framework that bridges the gap between traditional static analysis tools and Large Language Models (LLMs) specialized for code (CodeLLMs). CLDK simplifies multi-language code analysis by providing a unified Python library that integrates outputs from various analysis tools and prepares them for effective use by CodeLLMs.</p> <p>CLDK streamlines the process of transforming raw code into actionable insights, enabling robust analysis pipelines and seamless integration with tools like WALA, Tree-sitter, LLVM, and CodeQL.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>Get started with Codellm-Devkit:</p> <ul> <li> <p>  Quickstart</p> <p>Run through an example to quickly set up CLDK and perform multilingual code analysis.</p> </li> <li> <p>  Installing <code>cldk</code></p> <p>Install and initialize the <code>cldk</code> Python package to start analyzing your codebases.</p> </li> <li> <p>  Core Concepts</p> <p>Explore the key components of CLDK\u2014including data models and analysis backends\u2014that simplify code analysis workflows.</p> </li> <li> <p>  API Reference</p> <p>Developer-focused, detailed API reference documentation for <code>cldk</code>.</p> </li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Learn how to leverage CLDK for various code analysis tasks:</p> <ul> <li> <p>  Java Unit Test Generation</p> <p>Understand how to use CLDK to generate unit tests for Java projects.</p> </li> <li> <p> array-string  Summarize Python Projects</p> <p>Learn how to summarize Python projects using CLDK.</p> </li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<p>Dive deeper into advanced topics</p> <ul> <li> <p>  Extending CLDK</p> <p>Learn how to extend CLDK to a new language.</p> </li> <li> <p>  Adding a New Analysis Backend</p> <p>Learn how to add a new analysis backend to CLDK.</p> </li> </ul>"},{"location":"#why-codellm-devkit","title":"Why Codellm-Devkit?","text":"<p>TL;DR</p> <p>CLDK unifies traditional program analysis tools with CodeLLMs, streamlining multi-language code analysis into a single, cohesive framework.</p> <p>Current code analysis often involves juggling multiple disjointed tools and workflows. With Codellm-Devkit, you can:</p> <ul> <li>Unified: Integrate various analysis tools and CodeLLMs into one cohesive framework.</li> <li>Extensible: Easily add support for new tools and evolving LLM platforms.</li> <li>Streamlined: Simplify the transformation of raw code into structured, actionable insights.</li> </ul> <p>By providing a consistent and extensible interface, CLDK reduces friction and accelerates the development of robust analysis pipelines.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Rangeet Pan rangeet.pan@ibm.com Saurabh Sihna sinhas@us.ibm.com"},{"location":"installing/","title":"Installing <code>cldk</code>","text":"<p><code>CLDK</code> is a Python SDK hosted on PyPI and can be installed using your preferred Python package manager.</p>"},{"location":"installing/#installation","title":"Installation","text":"<p>The Python SDK can be installed directly from PyPI using any Python package manager such as pip, poetry, or uv:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk\n</code></pre> <pre><code>poetry add cldk\n</code></pre> <pre><code>uv add cldk\n</code></pre>"},{"location":"installing/#programming-language-specific-dependencies","title":"Programming Language Specific Dependencies","text":"<p><code>CLDK</code> supports program analysis for multiple languages and requires additional dependencies to support specific languages. The following table lists the additional dependencies required for each language:</p> Python AnalysisJava AnalysisC/C++ Analysis <p>For Python analysis as well as to use the CLDK Python SDK, you will need to install the Python programming language with version 3.11 or later. We recommend using a package manager like pyenv to install and manage Python dependencies.</p> <p>For Java analysis, CLDK relies on a companion project called <code>codeanalyzer</code>. <code>codeanalyzer</code> is a java project and you will therefore need to install the Java Development Kit (JDK) with java version 11 or later. </p> <p>You can use a package manager like SDKMAN to install the JDK. First, install SDKMAN by running the following command:</p> <ul> <li> <p>To install <code>SDKMan</code>, open your terminal and enter the following command and follow the instructions to complete the installation:</p> <pre><code>curl -s \"https://get.sdkman.io\" | bash\n</code></pre> </li> <li> <p>Open a new terminal or source the SDKMan! scripts:</p> <pre><code>source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n</code></pre> </li> </ul> <p>Next, install java 11 or later using SDKMAN:</p> <ul> <li> <p>You can list all available java versions with:</p> <pre><code>sdk list java | grep sem\n</code></pre> <p>You should see something like this: <pre><code>Semeru      |     | 21.0.5       | sem     |            | 21.0.5-sem\n            |     | 17.0.13      | sem     |            | 17.0.13-sem\n            |     | 11.0.25      | sem     |            | 11.0.25-sem\n            |     | 8.0.432      | sem     |            | 8.0.432-sem\n</code></pre></p> </li> <li> <p>Install Java 11 or above (we'll go with <code>11.0.25-sem</code>):</p> <pre><code>sdk install java 11.0.25-sem\n</code></pre> </li> <li> <p>Set Java 11 as the current (or default) Java version:</p> <pre><code>sdk use java 11.0.25-sem \n# If want to default to java 11 for all sessions, use the following command instead:\n# sdk default java 11.0.25-sem\n</code></pre> </li> <li> <p>Verify the installation:</p> <pre><code>java -version\n</code></pre> <p>This should output the version of the installed Java.</p> <pre><code>openjdk 11.0.25 2024-10-15\nIBM Semeru Runtime Open Edition 11.0.25.0 (build 11.0.25+9)\nEclipse OpenJ9 VM 11.0.25.0 (build openj9-0.48.0, JRE 11 Linux amd64-64-Bit Compressed References 20241107_1233 (JIT enabled, AOT enabled)\nOpenJ9   - 1d5831436e\nOMR      - d10a4d553\nJCL      - edded3f65c based on jdk-11.0.25+9)\n</code></pre> </li> </ul> <p>Finally, to enable building Java projects automatically, you will need to install the <code>maven</code> build tool. You can install <code>maven</code> using a package manager like <code>SDKMAN</code>:</p> <ul> <li> <p>Install Maven:</p> <pre><code>sdk install maven\n</code></pre> </li> <li> <p>Make sure <code>mvn</code> command is available in the <code>PATH</code>. If <code>mvn</code> is not in your path, add the following to your <code>~/.zshrc</code>, <code>~/.bashrc</code> or <code>~/.bash_profile</code> file:</p> <p><pre><code>export PATH=\"$HOME/.sdkman/candidates/maven/current/bin:$PATH\"\n</code></pre> Then, source the file to apply the changes:</p> <pre><code>source ~/.zshrc # or ~/.bashrc or ~/.bash_profile\n</code></pre> </li> <li> <p>Verify the installation:</p> <p><pre><code>mvn -version\n</code></pre> This should output the version of the installed Maven.</p> </li> </ul> <p>CLDK uses LLVM and Clang Python bindings to analyze C/C++ code. The project requires specific versions:</p> <ul> <li>libclang &gt;= 18.1.1</li> <li>clang &gt;= 17.0.6</li> </ul> <p>You can install LLVM and Clang using various package managers depending on your operating system.</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Install LLVM 18 using Homebrew <pre><code>brew install llvm@18\n</code></pre></p> </li> <li> <p>Add LLVM to your PATH (add this to your ~/.zshrc or ~/.bash_profile) <pre><code>export PATH=\"/usr/local/opt/llvm@18/bin:$PATH\"\nexport LDFLAGS=\"-L/usr/local/opt/llvm@18/lib\"\nexport CPPFLAGS=\"-I/usr/local/opt/llvm@18/include\"\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Apple clang version 18.1.1\nTarget: x86_64-apple-darwin21.6.0\nThread model: posix\nInstalledDir: /usr/local/opt/llvm@18/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Add LLVM repository and install required packages <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt-get install llvm-18 llvm-18-dev clang-18 libclang-18-dev\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Ubuntu clang version 18.1.1\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Install LLVM 18 and development packages <pre><code># On Fedora\nsudo dnf install llvm18 llvm18-devel clang18 clang18-devel\n\n# On CentOS/RHEL (if needed)\nsudo yum install epel-release\nsudo yum install llvm18 llvm18-devel clang18 clang18-devel\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>clang version 18.1.8 (Fedora 18.1.8-5.fc41)\nTarget: x86_64-redhat-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\nConfiguration file: /etc/clang18/x86_64-redhat-linux-gnu-clang.cfg\n</code></pre></p> </li> </ul>"},{"location":"installing/#additional-development-tools","title":"Additional Development Tools","text":"<p>Some operating systems may require additional development tools:</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Make sure you have the Xcode Command Line Tools installed. You can install them using the following command:</p> <pre><code>xcode-select --install\n</code></pre> </li> <li> <p>Additionally, you may need to install the following packages using Homebrew:</p> <pre><code>brew install openssl readline sqlite3 xz zlib tcl-tk libffi\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo apt-get install build-essential python3-dev libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev curl git \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo dnf group install c-development development-tools gcc make \\\npatch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel\\ \nopenssl-devel tk-devel libffi-devel xz-devel\n</code></pre> </li> </ul>"},{"location":"installing/#supported-python-versions","title":"Supported Python Versions","text":"<p><code>CLDK</code> is compatible with Python versions 3.11 and later. The following table lists the supported Python versions and the corresponding <code>CLDK</code> versions:</p>  Python Version  Compatible <code>cldk</code> Versions 3.11 \u22650.4.0"},{"location":"quickstart/","title":"Quickstart","text":"<p>Build code analysis pipelines with LLMs in minutes.</p> <p>In this quickstart guide, we will use the Apache Commons CLI example  codebase to demonstrate code analysis pipeline creation using CLDK, with both local LLM inference and automated code processing.</p> Installing CLDK and Ollama <p>This quickstart guide requires CLDK and Ollama. Follow these instructions to set up your environment:</p> <p>First, install CLDK and Ollama Python SDK:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <p>Then, install Ollama:  </p> Linux/WSLmacOS <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Or, download the installer from here.</p>"},{"location":"quickstart/#step-1-set-up-ollama-server","title":"Step 1: Set Up Ollama Server","text":"<p>Model inference with CLDK starts with a local LLM server. We'll use Ollama to host and run the models.</p> Linux/WSLmacOS <ul> <li> <p>Check if the Ollama server is running:     <pre><code>sudo systemctl status ollama\n</code></pre></p> </li> <li> <p>If not running, start it:     <pre><code>sudo systemctl start ollama\n</code></pre></p> </li> </ul> <p>On macOS, Ollama runs automatically after installation. </p> <p>You can check the status with: <pre><code>launchctl list | grep \"ollama\"\n</code></pre></p>"},{"location":"quickstart/#step-2-pull-the-code-llm","title":"Step 2: Pull the code LLM.","text":"<ul> <li> <p>Let's use the Granite 8b-instruct model for this tutorial:     <pre><code>ollama pull granite-code:8b-instruct\n</code></pre></p> </li> <li> <p>Verify the installation:     <pre><code>ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n</code></pre></p> <p>You should see a response like: <pre><code>\u276f ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n    ```python\n        def say_hello():\n            print(\"Hello World!\")\n    ```\n</code></pre></p> </li> </ul>"},{"location":"quickstart/#step-3-download-sample-codebase","title":"Step 3: Download Sample Codebase","text":"<p>We'll use Apache Commons CLI as our example Java project:</p> <pre><code>wget https://github.com/apache/commons-cli/archive/refs/tags/rel/commons-cli-1.7.0.zip -O commons-cli-1.7.0.zip &amp;&amp; unzip commons-cli-1.7.0.zip\n</code></pre> <p>Let's set the project path for future reference: <pre><code>export JAVA_APP_PATH=/path/to/commons-cli-1.7.0\n</code></pre></p> About the Sample Project <p>Apache Commons CLI provides an API for parsing command line options. It's a well-structured Java project that demonstrates various object-oriented patterns, making it ideal for code analysis experiments.</p>"},{"location":"quickstart/#step-3-create-analysis-pipeline","title":"Step 3: Create Analysis Pipeline","text":"What should I expect? <p>In about 40 lines of code, we will use CLDK to build a code summarization pipeline that leverages LLMs to generate summaries for a real world Java project! Without CLDK, this would require multiple tools and a much more complex setup.</p> <p>Let's build a pipeline that analyzes Java methods using LLMs. Create a new file <code>code_summarization.py</code>:</p> code_summarization.py<pre><code>import ollama\nfrom cldk import CLDK\nfrom pathlib import Path\nimport os\n\n# Create CLDK object, specify language as Java.\ncldk = CLDK(language=\"java\")  #  (1)!\n\n# Create analysis object\nanalysis = cldk.analysis(project_path=os.getenv(\"JAVA_APP_PATH\"))  #  (2)!\n\n# Iterate over files\nfor file_path, class_file in analysis.get_symbol_table().items():\n    # Iterate over classes\n    for type_name, type_declaration in class_file.type_declarations.items():\n        # Iterate over methods\n        for method in type_declaration.callable_declarations.values():  #  (3)!\n            # Skip constructors\n            if method.is_constructor:\n                continue\n            # Get code body\n            code_body = Path(file_path).absolute().resolve().read_text()\n\n            # Initialize treesitter\n            tree_sitter_utils = cldk.tree_sitter_utils(source_code=code_body)  # (4)!\n\n            # Sanitize class \n            sanitized_class = tree_sitter_utils.sanitize_focal_class(method.declaration)  # (5)!\n\n            # Format instruction\n            instruction = (\n                f\"Question: Can you write a brief summary for the method \" \n                f\"`{method.declaration}` in the class `{type_name}` below?\\n\\n\" \n                f\"```java\\n{sanitized_class}```\\n\"\n            )\n\n            # Prompt Ollama\n            summary = ollama.generate(\n                model=\"granite-code:8b-instruct\", # (6)!\n                prompt=instruction).get(\"response\") \n\n            # Print output\n            print(f\"\\nMethod: {method.declaration}\")\n            print(f\"Summary: {summary}\")\n</code></pre> <ol> <li>Create a new instance of the CLDK class</li> <li>Create an <code>analysis</code> instance for the Java project. This object will be used to obtain all the analysis artifacts from the java project.</li> <li>In a nested loop, we can quickly iterate over the methods in the project and extract the code body.</li> <li>CLDK comes with a number of treesitter based utilities that can be used to extract and manipulate code snippets. </li> <li>We use the <code>sanitize_focal_class()</code> method to extract the focal class for the method and sanitize any unwanted code in just one line of code.</li> <li>We use the <code>granite-code:8b-instruct</code> model in this example. Try a different model from Ollama model library.</li> </ol>"},{"location":"quickstart/#running-code_summarizationpy","title":"Running <code>code_summarization.py</code>","text":"<p>Save the file as <code>code_summarization.py</code> and run it: <pre><code>python code_summarization.py\n</code></pre></p> <p>You'll see output like: <pre><code>Method: parse\nSummary: This method parses command line arguments using the specified Options object...\n\nMethod: validateOption\nSummary: Validates if an option meets the required criteria including checking...\n\n...\n</code></pre></p>"},{"location":"quickstart/#step-5-customize-analysis","title":"Step 5: Customize Analysis","text":"<p>The pipeline can be customized in several ways:</p> Change ModelModify Prompt <p>Try different Granite model sizes: <pre><code>summary = ollama.generate(\n    model=\"granite-code:34b-instruct\",  # Larger model! \n    prompt=instruction).get(\"response\") \n</code></pre></p> <p>Adjust the task to generate a unit test: <pre><code>def format_inst(code, focal_method, focal_class):\n    return (f\"Generate a complete unit test case using junit4 for the method `{focal_method}`...\\n\\n\"\n            f\"```java\\n{code}```\\n\")\n</code></pre></p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore different analysis tasks like code repair, translation, test generation, and more...</li> <li>Create richer prompts with more analysis artifacts that CLDK provides.</li> <li>Implement batch processing for larger projects, or use the CLDK SDK to build custom analysis pipelines.</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>To be updated.</p>"}]}