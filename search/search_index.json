{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Codellm-Devkit (aka. CLDK) is a multilingual program analysis framework that bridges the gap between traditional static analysis tools and Large Language Models (LLMs) specialized for code (CodeLLMs). CLDK simplifies multi-language code analysis by providing a unified Python library that integrates outputs from various analysis tools and prepares them for effective use by CodeLLMs.</p> <p>CLDK streamlines the process of transforming raw code into actionable insights, enabling robust analysis pipelines and seamless integration with tools like WALA, Tree-sitter, LLVM, and CodeQL.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>Get started with Codellm-Devkit:</p> <ul> <li> <p>  Quickstart</p> <p>Run through an example to quickly set up CLDK and perform multilingual code analysis.</p> </li> <li> <p>  Installing <code>cldk</code></p> <p>Install and initialize the <code>cldk</code> Python package to start analyzing your codebases.</p> </li> <li> <p>  Core Concepts</p> <p>Explore the key components of CLDK\u2014including data models and analysis backends\u2014that simplify code analysis workflows.</p> </li> <li> <p>  Python API Reference</p> <p>Developer-focused, detailed API reference documentation for <code>cldk</code>.</p> </li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Learn how to leverage CLDK for various code analysis tasks:</p> <ul> <li> <p>  Java Unit Test Generation</p> <p>Understand how to use CLDK to generate unit tests for Java projects.</p> </li> <li> <p> array-string  Summarize Python Projects</p> <p>Learn how to summarize Python projects using CLDK.</p> </li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<p>Dive deeper into advanced topics</p> <ul> <li> <p>  Extending CLDK</p> <p>Learn how to extend CLDK to a new language.</p> </li> <li> <p>  Adding a New Analysis Backend</p> <p>Learn how to add a new analysis backend to CLDK.</p> </li> </ul>"},{"location":"#why-codellm-devkit","title":"Why Codellm-Devkit?","text":"<p>TL;DR</p> <p>CLDK unifies traditional program analysis tools with CodeLLMs, streamlining multi-language code analysis into a single, cohesive framework.</p> <p>Current code analysis often involves juggling multiple disjointed tools and workflows. With Codellm-Devkit, you can:</p> <ul> <li>Unified: Integrate various analysis tools and CodeLLMs into one cohesive framework.</li> <li>Extensible: Easily add support for new tools and evolving LLM platforms.</li> <li>Streamlined: Simplify the transformation of raw code into structured, actionable insights.</li> </ul> <p>By providing a consistent and extensible interface, CLDK reduces friction and accelerates the development of robust analysis pipelines.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Rangeet Pan rangeet.pan@ibm.com Saurabh Sihna sinhas@us.ibm.com"},{"location":"installing/","title":"Installing <code>cldk</code>","text":"<p><code>CLDK</code> is a Python SDK hosted on PyPI and can be installed using your preferred Python package manager.</p>"},{"location":"installing/#installation","title":"Installation","text":"<p>The Python SDK can be installed directly from PyPI using any Python package manager such as pip, poetry, or uv:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk\n</code></pre> <pre><code>poetry add cldk\n</code></pre> <pre><code>uv add cldk\n</code></pre>"},{"location":"installing/#programming-language-specific-dependencies","title":"Programming Language Specific Dependencies","text":"<p><code>CLDK</code> supports program analysis for multiple languages and requires additional dependencies to support specific languages. The following table lists the additional dependencies required for each language:</p> Python AnalysisJava AnalysisC/C++ AnalysisRust Installation <p>For Python analysis as well as to use the CLDK Python SDK, you will need to install the Python programming language with version 3.11 or later. We recommend using a package manager like pyenv to install and manage Python dependencies.</p> <p>For Java analysis, CLDK relies on a companion project called <code>codeanalyzer</code>. <code>codeanalyzer</code> is a java project and you will therefore need to install the Java Development Kit (JDK) with java version 11 or later.</p> <p>You can use a package manager like SDKMAN to install the JDK. First, install SDKMAN by running the following command:</p> <ul> <li> <p>To install <code>SDKMan</code>, open your terminal and enter the following command and follow the instructions to complete the installation:</p> <pre><code>curl -s \"https://get.sdkman.io\" | bash\n</code></pre> </li> <li> <p>Open a new terminal or source the SDKMan! scripts:</p> <pre><code>source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n</code></pre> </li> </ul> <p>Next, install java 11 or later using SDKMAN:</p> <ul> <li> <p>You can list all available java versions with:</p> <pre><code>sdk list java | grep sem\n</code></pre> <p>You should see something like this: <pre><code>Semeru      |     | 21.0.5       | sem     |            | 21.0.5-sem\n            |     | 17.0.13      | sem     |            | 17.0.13-sem\n            |     | 11.0.25      | sem     |            | 11.0.25-sem\n            |     | 8.0.432      | sem     |            | 8.0.432-sem\n</code></pre></p> </li> <li> <p>Install Java 11 or above (we'll go with <code>11.0.25-sem</code>):</p> <pre><code>sdk install java 11.0.25-sem\n</code></pre> </li> <li> <p>Set Java 11 as the current (or default) Java version:</p> <pre><code>sdk use java 11.0.25-sem\n# If want to default to java 11 for all sessions, use the following command instead:\n# sdk default java 11.0.25-sem\n</code></pre> </li> <li> <p>Verify the installation:</p> <pre><code>java -version\n</code></pre> <p>This should output the version of the installed Java.</p> <pre><code>openjdk 11.0.25 2024-10-15\nIBM Semeru Runtime Open Edition 11.0.25.0 (build 11.0.25+9)\nEclipse OpenJ9 VM 11.0.25.0 (build openj9-0.48.0, JRE 11 Linux amd64-64-Bit Compressed References 20241107_1233 (JIT enabled, AOT enabled)\nOpenJ9   - 1d5831436e\nOMR      - d10a4d553\nJCL      - edded3f65c based on jdk-11.0.25+9)\n</code></pre> </li> </ul> <p>Finally, to enable building Java projects automatically, you will need to install the <code>maven</code> build tool. You can install <code>maven</code> using a package manager like <code>SDKMAN</code>:</p> <ul> <li> <p>Install Maven:</p> <pre><code>sdk install maven\n</code></pre> </li> <li> <p>Make sure <code>mvn</code> command is available in the <code>PATH</code>. If <code>mvn</code> is not in your path, add the following to your <code>~/.zshrc</code>, <code>~/.bashrc</code> or <code>~/.bash_profile</code> file:</p> <p><pre><code>export PATH=\"$HOME/.sdkman/candidates/maven/current/bin:$PATH\"\n</code></pre> Then, source the file to apply the changes:</p> <pre><code>source ~/.zshrc # or ~/.bashrc or ~/.bash_profile\n</code></pre> </li> <li> <p>Verify the installation:</p> <p><pre><code>mvn -version\n</code></pre> This should output the version of the installed Maven.</p> </li> </ul> <p>CLDK uses LLVM and Clang Python bindings to analyze C/C++ code. The project requires specific versions:</p> <ul> <li>libclang &gt;= 18.1.1</li> <li>clang &gt;= 17.0.6</li> </ul> <p>You can install LLVM and Clang using various package managers depending on your operating system.</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Install LLVM 18 using Homebrew <pre><code>brew install llvm@18\n</code></pre></p> </li> <li> <p>Add LLVM to your PATH (add this to your ~/.zshrc or ~/.bash_profile) <pre><code>export PATH=\"/usr/local/opt/llvm@18/bin:$PATH\"\nexport LDFLAGS=\"-L/usr/local/opt/llvm@18/lib\"\nexport CPPFLAGS=\"-I/usr/local/opt/llvm@18/include\"\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Apple clang version 18.1.1\nTarget: x86_64-apple-darwin21.6.0\nThread model: posix\nInstalledDir: /usr/local/opt/llvm@18/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Add LLVM repository and install required packages <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt-get install llvm-18 llvm-18-dev clang-18 libclang-18-dev\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Ubuntu clang version 18.1.1\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Install LLVM 18 and development packages <pre><code># On Fedora\nsudo dnf install llvm18 llvm18-devel clang18 clang18-devel\n\n# On CentOS/RHEL (if needed)\nsudo yum install epel-release\nsudo yum install llvm18 llvm18-devel clang18 clang18-devel\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>clang version 18.1.8 (Fedora 18.1.8-5.fc41)\nTarget: x86_64-redhat-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\nConfiguration file: /etc/clang18/x86_64-redhat-linux-gnu-clang.cfg\n</code></pre></p> </li> </ul> <p>Rustup is the recommended tool for installing Rust and managing its toolchains. It simplifies the process of keeping Rust up to date and allows switching between different Rust versions and toolchains seamlessly.</p> <ul> <li> <p>Install Rustup Run the following command in your terminal: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> Follow the on-screen instructions to complete the installation.</p> </li> <li> <p>Configure Your Environment Add Rust to your PATH by appending this line to your shell init script: <pre><code>source $HOME/.cargo/env\n</code></pre></p> </li> <li> <p>Verify Installation Confirm that Rust is installed correctly by checking the version: <pre><code>rustc --version\n</code></pre> Expected output (version may vary): <pre><code>rustc 1.70.0 (90c541806 2023-05-31)\n</code></pre></p> </li> </ul>"},{"location":"installing/#additional-development-tools","title":"Additional Development Tools","text":"<p>Some operating systems may require additional development tools:</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Make sure you have the Xcode Command Line Tools installed. You can install them using the following command:</p> <pre><code>xcode-select --install\n</code></pre> </li> <li> <p>Additionally, you may need to install the following packages using Homebrew:</p> <pre><code>brew install openssl readline sqlite3 xz zlib tcl-tk libffi\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo apt-get install build-essential python3-dev libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev curl git \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo dnf group install c-development development-tools gcc make \\\npatch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel\\\nopenssl-devel tk-devel libffi-devel xz-devel\n</code></pre> </li> </ul>"},{"location":"installing/#supported-python-versions","title":"Supported Python Versions","text":"<p><code>CLDK</code> is compatible with Python versions 3.11 and later. The following table lists the supported Python versions and the corresponding <code>CLDK</code> versions:</p>  Python Version  Compatible <code>cldk</code> Versions 3.11 \u22650.4.0"},{"location":"quickstart/","title":"Quickstart","text":"<p>Build code analysis pipelines with LLMs in minutes.</p> <p>In this quickstart guide, we will use the Apache Commons CLI example  codebase to demonstrate code analysis pipeline creation using CLDK, with both local LLM inference and automated code processing.</p> Installing CLDK and Ollama <p>This quickstart guide requires CLDK and Ollama. Follow these instructions to set up your environment:</p> <p>First, install CLDK and Ollama Python SDK:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <p>Then, install Ollama:  </p> Linux/WSLmacOS <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Or, download the installer from here.</p>"},{"location":"quickstart/#step-1-set-up-ollama-server","title":"Step 1: Set Up Ollama Server","text":"<p>Model inference with CLDK starts with a local LLM server. We'll use Ollama to host and run the models.</p> Linux/WSLmacOS <ul> <li> <p>Check if the Ollama server is running:     <pre><code>sudo systemctl status ollama\n</code></pre></p> </li> <li> <p>If not running, start it:     <pre><code>sudo systemctl start ollama\n</code></pre></p> </li> </ul> <p>On macOS, Ollama runs automatically after installation. </p> <p>You can check the status with: <pre><code>launchctl list | grep \"ollama\"\n</code></pre></p>"},{"location":"quickstart/#step-2-pull-the-code-llm","title":"Step 2: Pull the code LLM.","text":"<ul> <li> <p>Let's use the Granite 8b-instruct model for this tutorial:     <pre><code>ollama pull granite-code:8b-instruct\n</code></pre></p> </li> <li> <p>Verify the installation:     <pre><code>ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n</code></pre></p> <p>You should see a response like: <pre><code>\u276f ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n    ```python\n        def say_hello():\n            print(\"Hello World!\")\n    ```\n</code></pre></p> </li> </ul>"},{"location":"quickstart/#step-3-download-sample-codebase","title":"Step 3: Download Sample Codebase","text":"<p>We'll use Apache Commons CLI as our example Java project:</p> <pre><code>wget https://github.com/apache/commons-cli/archive/refs/tags/rel/commons-cli-1.7.0.zip -O commons-cli-1.7.0.zip &amp;&amp; unzip commons-cli-1.7.0.zip\n</code></pre> <p>Let's set the project path for future reference: <pre><code>export JAVA_APP_PATH=/path/to/commons-cli-1.7.0\n</code></pre></p> About the Sample Project <p>Apache Commons CLI provides an API for parsing command line options. It's a well-structured Java project that demonstrates various object-oriented patterns, making it ideal for code analysis experiments.</p>"},{"location":"quickstart/#step-3-create-analysis-pipeline","title":"Step 3: Create Analysis Pipeline","text":"What should I expect? <p>In about 40 lines of code, we will use CLDK to build a code summarization pipeline that leverages LLMs to generate summaries for a real world Java project! Without CLDK, this would require multiple tools and a much more complex setup.</p> <p>Let's build a pipeline that analyzes Java methods using LLMs. Create a new file <code>code_summarization.py</code>:</p> code_summarization.py<pre><code>import ollama\nfrom cldk import CLDK\nfrom pathlib import Path\nimport os\n\n# Create CLDK object, specify language as Java.\ncldk = CLDK(language=\"java\")  #  (1)!\n\n# Create analysis object\nanalysis = cldk.analysis(project_path=os.getenv(\"JAVA_APP_PATH\"))  #  (2)!\n\n# Iterate over files\nfor file_path, class_file in analysis.get_symbol_table().items():\n    # Iterate over classes\n    for type_name, type_declaration in class_file.type_declarations.items():\n        # Iterate over methods\n        for method in type_declaration.callable_declarations.values():  #  (3)!\n            # Skip constructors\n            if method.is_constructor:\n                continue\n            # Get code body\n            code_body = Path(file_path).absolute().resolve().read_text()\n\n            # Initialize treesitter\n            tree_sitter_utils = cldk.tree_sitter_utils(source_code=code_body)  # (4)!\n\n            # Sanitize class \n            sanitized_class = tree_sitter_utils.sanitize_focal_class(method.declaration)  # (5)!\n\n            # Format instruction\n            instruction = (\n                f\"Question: Can you write a brief summary for the method \" \n                f\"`{method.declaration}` in the class `{type_name}` below?\\n\\n\" \n                f\"```java\\n{sanitized_class}```\\n\"\n            )\n\n            # Prompt Ollama\n            summary = ollama.generate(\n                model=\"granite-code:8b-instruct\", # (6)!\n                prompt=instruction).get(\"response\") \n\n            # Print output\n            print(f\"\\nMethod: {method.declaration}\")\n            print(f\"Summary: {summary}\")\n</code></pre> <ol> <li>Create a new instance of the CLDK class</li> <li>Create an <code>analysis</code> instance for the Java project. This object will be used to obtain all the analysis artifacts from the java project.</li> <li>In a nested loop, we can quickly iterate over the methods in the project and extract the code body.</li> <li>CLDK comes with a number of treesitter based utilities that can be used to extract and manipulate code snippets. </li> <li>We use the <code>sanitize_focal_class()</code> method to extract the focal class for the method and sanitize any unwanted code in just one line of code.</li> <li>We use the <code>granite-code:8b-instruct</code> model in this example. Try a different model from Ollama model library.</li> </ol>"},{"location":"quickstart/#running-code_summarizationpy","title":"Running <code>code_summarization.py</code>","text":"<p>Save the file as <code>code_summarization.py</code> and run it: <pre><code>python code_summarization.py\n</code></pre></p> <p>You'll see output like: <pre><code>Method: parse\nSummary: This method parses command line arguments using the specified Options object...\n\nMethod: validateOption\nSummary: Validates if an option meets the required criteria including checking...\n\n...\n</code></pre></p>"},{"location":"quickstart/#step-5-customize-analysis","title":"Step 5: Customize Analysis","text":"<p>The pipeline can be customized in several ways:</p> Change ModelModify Prompt <p>Try different Granite model sizes: <pre><code>summary = ollama.generate(\n    model=\"granite-code:34b-instruct\",  # Larger model! \n    prompt=instruction).get(\"response\") \n</code></pre></p> <p>Adjust the task to generate a unit test: <pre><code>def format_inst(code, focal_method, focal_class):\n    return (f\"Generate a complete unit test case using junit4 for the method `{focal_method}`...\\n\\n\"\n            f\"```java\\n{code}```\\n\")\n</code></pre></p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore different analysis tasks like code repair, translation, test generation, and more...</li> <li>Create richer prompts with more analysis artifacts that CLDK provides.</li> <li>Implement batch processing for larger projects, or use the CLDK SDK to build custom analysis pipelines.</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>To be updated.</p>"},{"location":"reference/python-api/","title":"API Reference","text":""},{"location":"reference/python-api/#overview","title":"Overview","text":"<p>Browse the CLDK API reference. Use the links below to view package-specific documentation.</p>"},{"location":"reference/python-api/#core","title":"Core","text":"<p>Fundamental building blocks of CLDK. See the Core API.</p>"},{"location":"reference/python-api/#java","title":"Java","text":"<p>Program analysis for Java and related data models. See the Java API.</p>"},{"location":"reference/python-api/#python","title":"Python","text":"<p>Program analysis for Python and related data models. See the Python API.</p>"},{"location":"reference/python-api/#cc","title":"C/C++","text":"<p>Program analysis for C/C++ and related data models. See the C/C++ API.</p>"},{"location":"reference/python-api/c-cpp/","title":"C/C++ API","text":"<p>This page documents the C and C++ related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the C/C++ analysis and schema packages.</p>"},{"location":"reference/python-api/c-cpp/#analysis","title":"Analysis","text":"<p>C/C++ analysis utilities and workflows.</p> <p>C analysis utilities.</p> <p>Provides a high-level API to analyze C projects using a Clang-based analyzer and to query functions, macros, typedefs, structs/unions, enums, and globals.</p>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis","title":"<code>CAnalysis</code>","text":"Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>class CAnalysis:\n\n    def __init__(self, project_dir: Path) -&gt; None:\n        \"\"\"Initialize the C analysis backend.\n\n        Args:\n            project_dir (Path): Path to the C project directory.\n        \"\"\"\n        if not isinstance(project_dir, Path):\n            project_dir = Path(project_dir)\n        self.c_application = self._init_application(project_dir)\n\n    def _init_application(self, project_dir: Path) -&gt; CApplication:\n        \"\"\"Construct the C application model from project sources.\n\n        Args:\n            project_dir (Path): Path to the project directory.\n\n        Returns:\n            CApplication: Application model.\n\n        Examples:\n            Build an application model from a project directory:\n\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; ca = CAnalysis(project_dir=Path('.'))  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(ca.get_c_application(), CApplication)  # doctest: +SKIP\n            True\n        \"\"\"\n        analyzer = ClangAnalyzer()\n\n        # Analyze each file\n        translation_units = {}\n        for source_file in project_dir.rglob(\"*.c\"):\n            tu = analyzer.analyze_file(source_file)\n            translation_units[str(source_file)] = tu\n\n        # Create application model\n        return CApplication(translation_units=translation_units)\n\n    def get_c_application(self) -&gt; CApplication:\n        \"\"\"Return the C application object.\n\n        Returns:\n            CApplication: Application model.\n\n        Examples:\n            &gt;&gt;&gt; # Assuming CAnalysis was constructed\n            &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_c_application(), CApplication)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.c_application\n\n    def get_imports(self) -&gt; List[str]:\n        \"\"\"Return all include/import statements in the project.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_imports()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_variables(self, **kwargs):\n        \"\"\"Return all variables discovered across the project.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_variables()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_application_view(self) -&gt; CApplication:\n        \"\"\"Return the application view of the C project.\n\n        Returns:\n            CApplication: Application model summarizing translation units.\n\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; ca = CAnalysis(project_dir=Path('.'))  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(ca.get_application_view(), CApplication)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.c_application\n\n    def get_symbol_table(self) -&gt; Dict[str, CTranslationUnit]:\n        \"\"\"Return a symbol table view keyed by file path.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_symbol_table()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_compilation_units(self) -&gt; List[CTranslationUnit]:\n        \"\"\"Return all compilation units parsed from C sources.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; from pathlib import Path\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_compilation_units()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def is_parsable(self, source_code: str) -&gt; bool:\n        \"\"\"Check if the source code is parsable using Clang.\n\n        Args:\n            source_code (str): Source code to parse.\n\n        Returns:\n            bool: True if parsable, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).is_parsable('int f(){return 1;}')  # doctest: +SKIP\n            True\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_call_graph(self) -&gt; nx.DiGraph:\n        \"\"\"Return the call graph of the C code.\n\n        Returns:\n            networkx.DiGraph: Call graph.\n\n        Examples:\n            &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph(), nx.DiGraph)  # doctest: +SKIP\n            True\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_call_graph_json(self) -&gt; str:\n        \"\"\"Return the call graph serialized as JSON.\n\n        Returns:\n            str: Call graph encoded as JSON.\n\n        Raises:\n            NotImplementedError: Single-file mode unsupported.\n\n        Examples:\n            &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph_json(), str)  # doctest: +SKIP\n            True\n        \"\"\"\n\n        raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n\n    def get_callers(self, function: CFunction) -&gt; Dict:\n        \"\"\"Return callers of a function.\n\n        Args:\n            function (CFunction): Target function.\n\n        Returns:\n            dict: Mapping of callers to call sites/details.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callers(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Generating all callers over a single file is not implemented yet.\n        \"\"\"\n\n        raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n\n    def get_callees(self, function: CFunction) -&gt; Dict:\n        \"\"\"Return callees of a function.\n\n        Args:\n            function (CFunction): Source function.\n\n        Returns:\n            dict: Callee details.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callees(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Generating all callees over a single file is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n\n    def get_functions(self) -&gt; Dict[str, CFunction]:\n        \"\"\"Return all functions in the project.\n\n        Returns:\n            dict[str, CFunction]: Functions keyed by signature/name for a translation unit.\n\n        Examples:\n            &gt;&gt;&gt; funcs = CAnalysis(project_dir=Path('.')).get_functions()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(funcs, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        for _, translation_unit in self.c_application.translation_units.items():\n            return translation_unit.functions\n\n    def get_function(self, function_name: str, file_name: Optional[str]) -&gt; CFunction | List[CFunction]:\n        \"\"\"Return a function object.\n\n        Args:\n            function_name (str): Function name.\n            file_name (str | None): Optional file name.\n\n        Returns:\n            CFunction | list[CFunction]: Function object(s) matching the query.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_function('main', None)  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_C_file(self, file_name: str) -&gt; str:\n        \"\"\"Return a C file path by name.\n\n        Args:\n            file_name (str): File name.\n\n        Returns:\n            str: C source file path.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_C_file('hello.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_C_compilation_unit(self, file_path: str) -&gt; CTranslationUnit:\n        \"\"\"Return the compilation unit for a C source file.\n\n        Args:\n            file_path (str): Absolute path to a C source file.\n\n        Returns:\n            CTranslationUnit: Compilation unit object.\n\n        Examples:\n            &gt;&gt;&gt; # Retrieve a compilation unit by path\n            &gt;&gt;&gt; cu = CAnalysis(project_dir=Path('.')).get_C_compilation_unit('file.c')  # doctest: +SKIP\n            &gt;&gt;&gt; (cu is None) or hasattr(cu, 'functions')  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.c_application.translation_units.get(file_path)\n\n    def get_functions_in_file(self, file_name: str) -&gt; List[CFunction]:\n        \"\"\"Return all functions in a given file.\n\n        Args:\n            file_name (str): File name.\n\n        Returns:\n            list[CFunction]: Functions in the file.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_functions_in_file('file.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_macros(self) -&gt; List[CMacro]:\n        \"\"\"Return all macros in the project.\n\n        Returns:\n            list[CMacro]: All macros.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_macros_in_file(self, file_name: str) -&gt; List[CMacro] | None:\n        \"\"\"Return all macros in the given file.\n\n        Args:\n            file_name (str): File name.\n\n        Returns:\n            list[CMacro] | None: Macros in the file, or None if not found.\n\n        Raises:\n            NotImplementedError: Not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros_in_file('file.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_c_application","title":"<code>get_c_application()</code>","text":"<p>Return the C application object.</p> <p>Returns:</p> Name Type Description <code>CApplication</code> <code>CApplication</code> <p>Application model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Assuming CAnalysis was constructed\n&gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_c_application(), CApplication)\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_c_application(self) -&gt; CApplication:\n    \"\"\"Return the C application object.\n\n    Returns:\n        CApplication: Application model.\n\n    Examples:\n        &gt;&gt;&gt; # Assuming CAnalysis was constructed\n        &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_c_application(), CApplication)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.c_application\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_imports","title":"<code>get_imports()</code>","text":"<p>Return all include/import statements in the project.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_imports()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_imports(self) -&gt; List[str]:\n    \"\"\"Return all include/import statements in the project.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_imports()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_variables","title":"<code>get_variables(**kwargs)</code>","text":"<p>Return all variables discovered across the project.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_variables()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_variables(self, **kwargs):\n    \"\"\"Return all variables discovered across the project.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_variables()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_application_view","title":"<code>get_application_view()</code>","text":"<p>Return the application view of the C project.</p> <p>Returns:</p> Name Type Description <code>CApplication</code> <code>CApplication</code> <p>Application model summarizing translation units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; ca = CAnalysis(project_dir=Path('.'))\n&gt;&gt;&gt; isinstance(ca.get_application_view(), CApplication)\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_application_view(self) -&gt; CApplication:\n    \"\"\"Return the application view of the C project.\n\n    Returns:\n        CApplication: Application model summarizing translation units.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; ca = CAnalysis(project_dir=Path('.'))  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(ca.get_application_view(), CApplication)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.c_application\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_symbol_table","title":"<code>get_symbol_table()</code>","text":"<p>Return a symbol table view keyed by file path.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_symbol_table()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_symbol_table(self) -&gt; Dict[str, CTranslationUnit]:\n    \"\"\"Return a symbol table view keyed by file path.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_symbol_table()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_compilation_units","title":"<code>get_compilation_units()</code>","text":"<p>Return all compilation units parsed from C sources.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_compilation_units()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_compilation_units(self) -&gt; List[CTranslationUnit]:\n    \"\"\"Return all compilation units parsed from C sources.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_compilation_units()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.is_parsable","title":"<code>is_parsable(source_code)</code>","text":"<p>Check if the source code is parsable using Clang.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to parse.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if parsable, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).is_parsable('int f(){return 1;}')\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def is_parsable(self, source_code: str) -&gt; bool:\n    \"\"\"Check if the source code is parsable using Clang.\n\n    Args:\n        source_code (str): Source code to parse.\n\n    Returns:\n        bool: True if parsable, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).is_parsable('int f(){return 1;}')  # doctest: +SKIP\n        True\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_call_graph","title":"<code>get_call_graph()</code>","text":"<p>Return the call graph of the C code.</p> <p>Returns:</p> Type Description <code>DiGraph</code> <p>networkx.DiGraph: Call graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph(), nx.DiGraph)\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_call_graph(self) -&gt; nx.DiGraph:\n    \"\"\"Return the call graph of the C code.\n\n    Returns:\n        networkx.DiGraph: Call graph.\n\n    Examples:\n        &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph(), nx.DiGraph)  # doctest: +SKIP\n        True\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_call_graph_json","title":"<code>get_call_graph_json()</code>","text":"<p>Return the call graph serialized as JSON.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Call graph encoded as JSON.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Single-file mode unsupported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph_json(), str)\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_call_graph_json(self) -&gt; str:\n    \"\"\"Return the call graph serialized as JSON.\n\n    Returns:\n        str: Call graph encoded as JSON.\n\n    Raises:\n        NotImplementedError: Single-file mode unsupported.\n\n    Examples:\n        &gt;&gt;&gt; isinstance(CAnalysis(project_dir=Path('.')).get_call_graph_json(), str)  # doctest: +SKIP\n        True\n    \"\"\"\n\n    raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_callers","title":"<code>get_callers(function)</code>","text":"<p>Return callers of a function.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>CFunction</code> <p>Target function.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Mapping of callers to call sites/details.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callers(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))\nTraceback (most recent call last):\nNotImplementedError: Generating all callers over a single file is not implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_callers(self, function: CFunction) -&gt; Dict:\n    \"\"\"Return callers of a function.\n\n    Args:\n        function (CFunction): Target function.\n\n    Returns:\n        dict: Mapping of callers to call sites/details.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callers(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Generating all callers over a single file is not implemented yet.\n    \"\"\"\n\n    raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_callees","title":"<code>get_callees(function)</code>","text":"<p>Return callees of a function.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>CFunction</code> <p>Source function.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Callee details.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callees(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))\nTraceback (most recent call last):\nNotImplementedError: Generating all callees over a single file is not implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_callees(self, function: CFunction) -&gt; Dict:\n    \"\"\"Return callees of a function.\n\n    Args:\n        function (CFunction): Source function.\n\n    Returns:\n        dict: Callee details.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_callees(CFunction(name='f', return_type='int', parameters=[], storage_class=None, is_inline=False, is_variadic=False, body='', comment='', call_sites=[], local_variables=[], start_line=1, end_line=1))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Generating all callees over a single file is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_functions","title":"<code>get_functions()</code>","text":"<p>Return all functions in the project.</p> <p>Returns:</p> Type Description <code>Dict[str, CFunction]</code> <p>dict[str, CFunction]: Functions keyed by signature/name for a translation unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; funcs = CAnalysis(project_dir=Path('.')).get_functions()\n&gt;&gt;&gt; isinstance(funcs, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_functions(self) -&gt; Dict[str, CFunction]:\n    \"\"\"Return all functions in the project.\n\n    Returns:\n        dict[str, CFunction]: Functions keyed by signature/name for a translation unit.\n\n    Examples:\n        &gt;&gt;&gt; funcs = CAnalysis(project_dir=Path('.')).get_functions()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(funcs, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    for _, translation_unit in self.c_application.translation_units.items():\n        return translation_unit.functions\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_function","title":"<code>get_function(function_name, file_name)</code>","text":"<p>Return a function object.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>Function name.</p> required <code>file_name</code> <code>str | None</code> <p>Optional file name.</p> required <p>Returns:</p> Type Description <code>CFunction | List[CFunction]</code> <p>CFunction | list[CFunction]: Function object(s) matching the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_function('main', None)\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_function(self, function_name: str, file_name: Optional[str]) -&gt; CFunction | List[CFunction]:\n    \"\"\"Return a function object.\n\n    Args:\n        function_name (str): Function name.\n        file_name (str | None): Optional file name.\n\n    Returns:\n        CFunction | list[CFunction]: Function object(s) matching the query.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_function('main', None)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_C_file","title":"<code>get_C_file(file_name)</code>","text":"<p>Return a C file path by name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>C source file path.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_C_file('hello.c')\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_C_file(self, file_name: str) -&gt; str:\n    \"\"\"Return a C file path by name.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        str: C source file path.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_C_file('hello.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_C_compilation_unit","title":"<code>get_C_compilation_unit(file_path)</code>","text":"<p>Return the compilation unit for a C source file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute path to a C source file.</p> required <p>Returns:</p> Name Type Description <code>CTranslationUnit</code> <code>CTranslationUnit</code> <p>Compilation unit object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Retrieve a compilation unit by path\n&gt;&gt;&gt; cu = CAnalysis(project_dir=Path('.')).get_C_compilation_unit('file.c')\n&gt;&gt;&gt; (cu is None) or hasattr(cu, 'functions')\nTrue\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_C_compilation_unit(self, file_path: str) -&gt; CTranslationUnit:\n    \"\"\"Return the compilation unit for a C source file.\n\n    Args:\n        file_path (str): Absolute path to a C source file.\n\n    Returns:\n        CTranslationUnit: Compilation unit object.\n\n    Examples:\n        &gt;&gt;&gt; # Retrieve a compilation unit by path\n        &gt;&gt;&gt; cu = CAnalysis(project_dir=Path('.')).get_C_compilation_unit('file.c')  # doctest: +SKIP\n        &gt;&gt;&gt; (cu is None) or hasattr(cu, 'functions')  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.c_application.translation_units.get(file_path)\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_functions_in_file","title":"<code>get_functions_in_file(file_name)</code>","text":"<p>Return all functions in a given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CFunction]</code> <p>list[CFunction]: Functions in the file.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_functions_in_file('file.c')\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_functions_in_file(self, file_name: str) -&gt; List[CFunction]:\n    \"\"\"Return all functions in a given file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CFunction]: Functions in the file.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_functions_in_file('file.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_macros","title":"<code>get_macros()</code>","text":"<p>Return all macros in the project.</p> <p>Returns:</p> Type Description <code>List[CMacro]</code> <p>list[CMacro]: All macros.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_macros(self) -&gt; List[CMacro]:\n    \"\"\"Return all macros in the project.\n\n    Returns:\n        list[CMacro]: All macros.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.CAnalysis.get_macros_in_file","title":"<code>get_macros_in_file(file_name)</code>","text":"<p>Return all macros in the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CMacro] | None</code> <p>list[CMacro] | None: Macros in the file, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros_in_file('file.c')\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_macros_in_file(self, file_name: str) -&gt; List[CMacro] | None:\n    \"\"\"Return all macros in the given file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CMacro] | None: Macros in the file, or None if not found.\n\n    Raises:\n        NotImplementedError: Not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; CAnalysis(project_dir=Path('.')).get_macros_in_file('file.c')  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_includes","title":"<code>get_includes(self)</code>","text":"<p>Return all include statements across the project.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: All include statements.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_includes(self) -&gt; List[str]:\n    \"\"\"Return all include statements across the project.\n\n    Returns:\n        list[str]: All include statements.\n    \"\"\"\n    all_includes = []\n    for translation_unit in self.translation_units.values():\n        all_includes.extend(translation_unit.includes)\n    return all_includes\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_includes_in_file","title":"<code>get_includes_in_file(self, file_name)</code>","text":"<p>Return include statements in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[str] | None</code> <p>list[str] | None: Includes in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_includes_in_file(self, file_name: str) -&gt; List[str] | None:\n    \"\"\"Return include statements in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[str] | None: Includes in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].includes\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_macros","title":"<code>get_macros(self)</code>","text":"<p>Return all macro definitions across the project.</p> <p>Returns:</p> Type Description <code>List[CMacro]</code> <p>list[CMacro]: Macro definitions.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_macros(self) -&gt; List[CMacro]:\n    \"\"\"Return all macro definitions across the project.\n\n    Returns:\n        list[CMacro]: Macro definitions.\n    \"\"\"\n    all_macros = []\n    for translation_unit in self.translation_units.values():\n        all_macros.extend(translation_unit.macros)\n    return all_macros\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_macros_in_file","title":"<code>get_macros_in_file(self, file_name)</code>","text":"<p>Return macro definitions in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CMacro] | None</code> <p>list[CMacro] | None: Macros in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_macros_in_file(self, file_name: str) -&gt; List[CMacro] | None:\n    \"\"\"Return macro definitions in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CMacro] | None: Macros in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].macros\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_typedefs","title":"<code>get_typedefs(self)</code>","text":"<p>Return typedef declarations across the project.</p> <p>Returns:</p> Type Description <code>List[CTypedef]</code> <p>list[CTypedef]: Typedef declarations.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_typedefs(self) -&gt; List[CTypedef]:\n    \"\"\"Return typedef declarations across the project.\n\n    Returns:\n        list[CTypedef]: Typedef declarations.\n    \"\"\"\n    all_typedefs = []\n    for translation_unit in self.translation_units.values():\n        all_typedefs.extend(translation_unit.typedefs)\n    return all_typedefs\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_typedefs_in_file","title":"<code>get_typedefs_in_file(self, file_name)</code>","text":"<p>Return typedef declarations in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CTypedef] | None</code> <p>list[CTypedef] | None: Typedefs in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_typedefs_in_file(self, file_name: str) -&gt; List[CTypedef] | None:\n    \"\"\"Return typedef declarations in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CTypedef] | None: Typedefs in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].typedefs\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_structs","title":"<code>get_structs(self)</code>","text":"<p>Return struct/union declarations across the project.</p> <p>Returns:</p> Type Description <code>List[CStruct]</code> <p>list[CStruct]: Struct/union declarations.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_structs(self) -&gt; List[CStruct]:\n    \"\"\"Return struct/union declarations across the project.\n\n    Returns:\n        list[CStruct]: Struct/union declarations.\n    \"\"\"\n    all_structs = []\n    for translation_unit in self.translation_units.values():\n        all_structs.extend(translation_unit.structs)\n    return all_structs\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_structs_in_file","title":"<code>get_structs_in_file(self, file_name)</code>","text":"<p>Return struct/union declarations in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CStruct] | None</code> <p>list[CStruct] | None: Structs in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_structs_in_file(self, file_name: str) -&gt; List[CStruct] | None:\n    \"\"\"Return struct/union declarations in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CStruct] | None: Structs in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].structs\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_enums","title":"<code>get_enums(self)</code>","text":"<p>Return enum declarations across the project.</p> <p>Returns:</p> Type Description <code>List[CEnum]</code> <p>list[CEnum]: Enum declarations.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_enums(self) -&gt; List[CEnum]:\n    \"\"\"Return enum declarations across the project.\n\n    Returns:\n        list[CEnum]: Enum declarations.\n    \"\"\"\n    all_enums = []\n    for translation_unit in self.translation_units.values():\n        all_enums.extend(translation_unit.enums)\n    return all_enums\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_enums_in_file","title":"<code>get_enums_in_file(self, file_name)</code>","text":"<p>Return enum declarations in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CEnum] | None</code> <p>list[CEnum] | None: Enums in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_enums_in_file(self, file_name: str) -&gt; List[CEnum] | None:\n    \"\"\"Return enum declarations in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CEnum] | None: Enums in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].enums\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.analysis.c.c_analysis.get_globals","title":"<code>get_globals(self, file_name)</code>","text":"<p>Return global variable declarations in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File name.</p> required <p>Returns:</p> Type Description <code>List[CVariable] | None</code> <p>list[CVariable] | None: Globals in the file, or None if not found.</p> Source code in <code>cldk/analysis/c/c_analysis.py</code> <pre><code>def get_globals(self, file_name: str) -&gt; List[CVariable] | None:\n    \"\"\"Return global variable declarations in a file.\n\n    Args:\n        file_name (str): File name.\n\n    Returns:\n        list[CVariable] | None: Globals in the file, or None if not found.\n    \"\"\"\n    if file_name in self.translation_units:\n        return self.translation_units[file_name].globals\n    return None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#schema","title":"Schema","text":"<p>Data models used by the C/C++ analyzers.</p>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.StorageClass","title":"<code>StorageClass</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents C storage class specifiers.</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class StorageClass(Enum):\n    \"\"\"Represents C storage class specifiers.\"\"\"\n\n    AUTO = \"auto\"\n    REGISTER = \"register\"\n    STATIC = \"static\"\n    EXTERN = \"extern\"\n    TYPEDEF = \"typedef\"\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CVariable","title":"<code>CVariable</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a variable declaration in C.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the variable</p> <code>type</code> <code>str</code> <p>The type of the variable (including any type qualifiers)</p> <code>storage_class</code> <code>Optional[StorageClass]</code> <p>The storage class specifier (if any)</p> <code>is_const</code> <code>bool</code> <p>Whether the variable is const-qualified</p> <code>is_volatile</code> <code>bool</code> <p>Whether the variable is volatile-qualified</p> <code>initializer</code> <code>str</code> <p>Initial value expression, if any</p> <code>array_dimensions</code> <code>List[str]</code> <p>Dimensions if this is an array variable</p> <code>is_pointer</code> <code>bool</code> <p>Whether this is a pointer variable</p> <code>pointer_level</code> <code>int</code> <p>Level of pointer indirection (e.g., 2 for char**)</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CVariable(BaseModel):\n    \"\"\"Represents a variable declaration in C.\n\n    Attributes:\n        name (str): The name of the variable\n        type (str): The type of the variable (including any type qualifiers)\n        storage_class: The storage class specifier (if any)\n        is_const (bool): Whether the variable is const-qualified\n        is_volatile (bool): Whether the variable is volatile-qualified\n        initializer (str): Initial value expression, if any\n        array_dimensions (List[str]): Dimensions if this is an array variable\n        is_pointer (bool): Whether this is a pointer variable\n        pointer_level (int): Level of pointer indirection (e.g., 2 for char**)\n    \"\"\"\n\n    name: str\n    type: str\n    storage_class: Optional[StorageClass] = None\n    is_const: bool = False\n    is_volatile: bool = False\n    initializer: Optional[str] = None\n    array_dimensions: List[str] = []\n    is_pointer: bool = False\n    pointer_level: int = 0\n    start_line: int\n    end_line: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CFunctionPointer","title":"<code>CFunctionPointer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a function pointer type.</p> <p>Attributes:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Return type of the function being pointed to</p> <code>parameter_types</code> <code>List[str]</code> <p>Types of the parameters</p> <code>calling_convention</code> <code>Optional[str]</code> <p>Calling convention if specified</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CFunctionPointer(BaseModel):\n    \"\"\"Represents a function pointer type.\n\n    Attributes:\n        return_type (str): Return type of the function being pointed to\n        parameter_types (List[str]): Types of the parameters\n        calling_convention (Optional[str]): Calling convention if specified\n    \"\"\"\n\n    return_type: str\n    parameter_types: List[str]\n    calling_convention: Optional[str] = None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CMacro","title":"<code>CMacro</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C preprocessor macro.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the macro</p> <code>parameters</code> <code>List[str]</code> <p>Parameters for function-like macros</p> <code>replacement</code> <code>str</code> <p>Replacement text</p> <code>is_function_like</code> <code>bool</code> <p>Whether this is a function-like macro</p> <code>start_line</code> <code>int</code> <p>Starting line in source</p> <code>end_line</code> <code>int</code> <p>Ending line in source</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CMacro(BaseModel):\n    \"\"\"Represents a C preprocessor macro.\n\n    Attributes:\n        name (str): Name of the macro\n        parameters (List[str]): Parameters for function-like macros\n        replacement (str): Replacement text\n        is_function_like (bool): Whether this is a function-like macro\n        start_line (int): Starting line in source\n        end_line (int): Ending line in source\n    \"\"\"\n\n    name: str\n    parameters: List[str] = []\n    replacement: str\n    is_function_like: bool = False\n    start_line: int\n    end_line: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CParameter","title":"<code>CParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a parameter in a function declaration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Parameter name (may be empty in declarations)</p> <code>type</code> <code>str</code> <p>Parameter type</p> <code>is_const</code> <code>bool</code> <p>Whether parameter is const-qualified</p> <code>is_volatile</code> <code>bool</code> <p>Whether parameter is volatile-qualified</p> <code>is_pointer</code> <code>bool</code> <p>Whether parameter is a pointer</p> <code>pointer_level</code> <code>int</code> <p>Level of pointer indirection</p> <code>array_dimensions</code> <code>List[str]</code> <p>Array dimensions if parameter is array</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CParameter(BaseModel):\n    \"\"\"Represents a parameter in a function declaration.\n\n    Attributes:\n        name (str): Parameter name (may be empty in declarations)\n        type (str): Parameter type\n        is_const (bool): Whether parameter is const-qualified\n        is_volatile (bool): Whether parameter is volatile-qualified\n        is_pointer (bool): Whether parameter is a pointer\n        pointer_level (int): Level of pointer indirection\n        array_dimensions (List[str]): Array dimensions if parameter is array\n    \"\"\"\n\n    name: str\n    type: str\n    is_const: bool = False\n    is_volatile: bool = False\n    is_pointer: bool = False\n    pointer_level: int = 0\n    array_dimensions: List[str] = []\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CCallSite","title":"<code>CCallSite</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a function call in C code.</p> <p>Attributes:</p> Name Type Description <code>function_name</code> <code>str</code> <p>Name of the called function</p> <code>argument_types</code> <code>List[str]</code> <p>Types of the arguments</p> <code>is_indirect_call</code> <code>bool</code> <p>Whether this is a call through function pointer</p> <code>is_macro_expansion</code> <code>bool</code> <p>Whether this call is from macro expansion</p> <code>return_type</code> <code>str</code> <p>Return type of the called function</p> <code>start_line</code> <code>int</code> <p>Starting line of the call</p> <code>start_column</code> <code>int</code> <p>Starting column of the call</p> <code>end_line</code> <code>int</code> <p>Ending line of the call</p> <code>end_column</code> <code>int</code> <p>Ending column of the call</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CCallSite(BaseModel):\n    \"\"\"Represents a function call in C code.\n\n    Attributes:\n        function_name (str): Name of the called function\n        argument_types (List[str]): Types of the arguments\n        is_indirect_call (bool): Whether this is a call through function pointer\n        is_macro_expansion (bool): Whether this call is from macro expansion\n        return_type (str): Return type of the called function\n        start_line (int): Starting line of the call\n        start_column (int): Starting column of the call\n        end_line (int): Ending line of the call\n        end_column (int): Ending column of the call\n    \"\"\"\n\n    function_name: str\n    argument_types: List[str]\n    is_indirect_call: bool = False\n    is_macro_expansion: bool = False\n    return_type: str = \"\"\n    start_line: int\n    start_column: int\n    end_line: int\n    end_column: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CFunction","title":"<code>CFunction</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Function name</p> <code>return_type</code> <code>str</code> <p>Return type</p> <code>parameters</code> <code>List[CParameter]</code> <p>Function parameters</p> <code>storage_class</code> <code>Optional[StorageClass]</code> <p>Storage class if specified</p> <code>is_inline</code> <code>bool</code> <p>Whether function is inline</p> <code>is_const</code> <code>bool</code> <p>Whether function is const-qualified (C++)</p> <code>is_variadic</code> <code>bool</code> <p>Whether function takes variable arguments</p> <code>body</code> <code>str</code> <p>Function body code</p> <code>comment</code> <code>str</code> <p>Associated comments/documentation</p> <code>referenced_types</code> <code>List[str]</code> <p>Types referenced in function</p> <code>accessed_globals</code> <code>List[str]</code> <p>Global variables accessed</p> <code>call_sites</code> <code>List[CCallSite]</code> <p>Function calls made</p> <code>local_variables</code> <code>List[CVariable]</code> <p>Local variable declarations</p> <code>macros_used</code> <code>List[str]</code> <p>Macros used in function</p> <code>start_line</code> <code>int</code> <p>Starting line in source</p> <code>end_line</code> <code>int</code> <p>Ending line in source</p> <code>cyclomatic_complexity</code> <code>Optional[int]</code> <p>Cyclomatic complexity if calculated</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CFunction(BaseModel):\n    \"\"\"Represents a C function.\n\n    Attributes:\n        name (str): Function name\n        return_type (str): Return type\n        parameters (List[CParameter]): Function parameters\n        storage_class (Optional[StorageClass]): Storage class if specified\n        is_inline (bool): Whether function is inline\n        is_const (bool): Whether function is const-qualified (C++)\n        is_variadic (bool): Whether function takes variable arguments\n        body (str): Function body code\n        comment (str): Associated comments/documentation\n        referenced_types (List[str]): Types referenced in function\n        accessed_globals (List[str]): Global variables accessed\n        call_sites (List[CCallSite]): Function calls made\n        local_variables (List[CVariable]): Local variable declarations\n        macros_used (List[str]): Macros used in function\n        start_line (int): Starting line in source\n        end_line (int): Ending line in source\n        cyclomatic_complexity (Optional[int]): Cyclomatic complexity if calculated\n    \"\"\"\n\n    name: str\n    return_type: str\n    parameters: List[CParameter]\n    storage_class: Optional[StorageClass] = None\n    is_inline: bool = False\n    is_const: bool = False\n    is_variadic: bool = False\n    body: str\n    comment: str = \"\"\n    referenced_types: List[str] = []\n    accessed_globals: List[str] = []\n    call_sites: List[CCallSite] = []\n    local_variables: List[CVariable] = []\n    macros_used: List[str] = []\n    start_line: int\n    end_line: int\n    cyclomatic_complexity: Optional[int] = None\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CStruct","title":"<code>CStruct</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C struct or union.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the struct</p> <code>is_union</code> <code>bool</code> <p>Whether this is a union</p> <code>members</code> <code>List[CVariable]</code> <p>Member variables</p> <code>is_packed</code> <code>bool</code> <p>Whether struct is packed</p> <code>alignment</code> <code>Optional[int]</code> <p>Specified alignment if any</p> <code>comment</code> <code>str</code> <p>Associated comments</p> <code>referenced_types</code> <code>List[str]</code> <p>Types referenced in struct</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CStruct(BaseModel):\n    \"\"\"Represents a C struct or union.\n\n    Attributes:\n        name (str): Name of the struct\n        is_union (bool): Whether this is a union\n        members (List[CVariable]): Member variables\n        is_packed (bool): Whether struct is packed\n        alignment (Optional[int]): Specified alignment if any\n        comment (str): Associated comments\n        referenced_types (List[str]): Types referenced in struct\n    \"\"\"\n\n    name: str\n    is_union: bool = False\n    members: List[CVariable]\n    is_packed: bool = False\n    alignment: Optional[int] = None\n    comment: str = \"\"\n    referenced_types: List[str] = []\n    start_line: int\n    end_line: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CEnum","title":"<code>CEnum</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C enum declaration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the enum</p> <code>constants</code> <code>Dict[str, int]</code> <p>Enum constants and their values</p> <code>comment</code> <code>str</code> <p>Associated comments</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CEnum(BaseModel):\n    \"\"\"Represents a C enum declaration.\n\n    Attributes:\n        name (str): Name of the enum\n        constants (Dict[str, int]): Enum constants and their values\n        comment (str): Associated comments\n    \"\"\"\n\n    name: str\n    constants: Dict[str, int]\n    comment: str = \"\"\n    start_line: int\n    end_line: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CTypedef","title":"<code>CTypedef</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a typedef declaration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>New type name being defined</p> <code>underlying_type</code> <code>str</code> <p>The actual type being aliased</p> <code>is_function_pointer</code> <code>bool</code> <p>Whether this is a function pointer typedef</p> <code>function_pointer</code> <code>Optional[CFunctionPointer]</code> <p>Details if this is a function pointer typedef</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CTypedef(BaseModel):\n    \"\"\"Represents a typedef declaration.\n\n    Attributes:\n        name (str): New type name being defined\n        underlying_type (str): The actual type being aliased\n        is_function_pointer (bool): Whether this is a function pointer typedef\n        function_pointer: Details if this is a function pointer typedef\n    \"\"\"\n\n    name: str\n    underlying_type: str\n    is_function_pointer: bool = False\n    function_pointer: Optional[CFunctionPointer] = None\n    start_line: int\n    end_line: int\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CInclude","title":"<code>CInclude</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C include directive.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the included file</p> <code>is_system</code> <code>bool</code> <p>Whether this is a system include</p> <code>line_number</code> <code>int</code> <p>Line number in source</p> <code>full_text</code> <code>str</code> <p>Full text of the include directive</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CInclude(BaseModel):\n    \"\"\"Represents a C include directive.\n\n    Attributes:\n        name (str): Name of the included file\n        is_system (bool): Whether this is a system include\n        line_number (int): Line number in source\n        full_text (str): Full text of the include directive\n    \"\"\"\n\n    name: str\n    is_system: bool\n    line_number: int\n    full_text: str\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CTranslationUnit","title":"<code>CTranslationUnit</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a C source file.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>Path to the source file</p> <code>includes</code> <code>List[str]</code> <p>Header files included</p> <code>macros</code> <code>List[CMacro]</code> <p>Macro definitions</p> <code>typedefs</code> <code>List[CTypedef]</code> <p>Typedef declarations</p> <code>structs</code> <code>List[CStruct]</code> <p>Struct/union declarations</p> <code>enums</code> <code>List[CEnum]</code> <p>Enum declarations</p> <code>globals</code> <code>List[CVariable]</code> <p>Global variable declarations</p> <code>functions</code> <code>Dict[str, CFunction]</code> <p>Function declarations/definitions</p> <code>is_header</code> <code>bool</code> <p>Whether this is a header file</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CTranslationUnit(BaseModel):\n    \"\"\"Represents a C source file.\n\n    Attributes:\n        file_path (str): Path to the source file\n        includes (List[str]): Header files included\n        macros (List[CMacro]): Macro definitions\n        typedefs (List[CTypedef]): Typedef declarations\n        structs (List[CStruct]): Struct/union declarations\n        enums (List[CEnum]): Enum declarations\n        globals (List[CVariable]): Global variable declarations\n        functions (Dict[str, CFunction]): Function declarations/definitions\n        is_header (bool): Whether this is a header file\n    \"\"\"\n\n    file_path: str\n    includes: List[CInclude] = []\n    macros: List[CMacro] = []\n    typedefs: List[CTypedef] = []\n    structs: List[CStruct] = []\n    enums: List[CEnum] = []\n    globals: List[CVariable] = []\n    functions: Dict[str, CFunction] = {}\n    is_header: bool = False\n    is_modified: bool = False\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CFunctionDetail","title":"<code>CFunctionDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents detailed information about a function.</p> <p>Attributes:</p> Name Type Description <code>function_declaration</code> <code>str</code> <p>Full function declaration</p> <code>file_path</code> <code>str</code> <p>Path to the file containing the function</p> <code>function</code> <code>CFunction</code> <p>Detailed function information</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CFunctionDetail(BaseModel):\n    \"\"\"Represents detailed information about a function.\n\n    Attributes:\n        function_declaration (str): Full function declaration\n        file_path (str): Path to the file containing the function\n        function (CFunction): Detailed function information\n    \"\"\"\n\n    function_declaration: str\n    file_path: str\n    function: CFunction\n\n    def __hash__(self):\n        return hash((self.function_declaration, self.file_path))\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CCallGraphEdge","title":"<code>CCallGraphEdge</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an edge in the call graph.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>CFunctionDetail</code> <p>Calling function</p> <code>target</code> <code>CFunctionDetail</code> <p>Called function</p> <code>type</code> <code>str</code> <p>Type of call relationship</p> <code>weight</code> <code>str</code> <p>Edge weight/importance</p> <code>is_indirect</code> <code>bool</code> <p>Whether this is through function pointer</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CCallGraphEdge(BaseModel):\n    \"\"\"Represents an edge in the call graph.\n\n    Attributes:\n        source (CFunctionDetail): Calling function\n        target (CFunctionDetail): Called function\n        type (str): Type of call relationship\n        weight (str): Edge weight/importance\n        is_indirect (bool): Whether this is through function pointer\n    \"\"\"\n\n    source: CFunctionDetail\n    target: CFunctionDetail\n    type: str\n    weight: str\n    is_indirect: bool = False\n</code></pre>"},{"location":"reference/python-api/c-cpp/#cldk.models.c.models.CApplication","title":"<code>CApplication</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a complete C application.</p> <p>Attributes:</p> Name Type Description <code>translation_units</code> <code>Dict[str, CTranslationUnit]</code> <p>All source files</p> <code>call_graph</code> <code>List[CCallGraphEdge]</code> <p>Function call relationships</p> Source code in <code>cldk/models/c/models.py</code> <pre><code>class CApplication(BaseModel):\n    \"\"\"Represents a complete C application.\n\n    Attributes:\n        translation_units (Dict[str, CTranslationUnit]): All source files\n        call_graph (List[CCallGraphEdge]): Function call relationships\n    \"\"\"\n\n    translation_units: Dict[str, CTranslationUnit]\n    call_graph: List[CCallGraphEdge] = []\n</code></pre>"},{"location":"reference/python-api/core/","title":"Core API","text":"<p>Core CLDK module.</p> <p>Provides the top-level CLDK entry point used to initialize language-specific analysis, Treesitter parsers, and related utilities.</p>"},{"location":"reference/python-api/core/#cldk.core.CLDK","title":"<code>CLDK</code>","text":"<p>Core class for the Code Language Development Kit (CLDK).</p> <p>Initialize with the desired programming language and use the exposed helpers to perform language-specific analysis.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Programming language (e.g., \"java\", \"python\", \"c\").</p> required <p>Attributes:</p> Name Type Description <code>language</code> <code>str</code> <p>Programming language of the project.</p> Source code in <code>cldk/core.py</code> <pre><code>class CLDK:\n    \"\"\"Core class for the Code Language Development Kit (CLDK).\n\n    Initialize with the desired programming language and use the exposed\n    helpers to perform language-specific analysis.\n\n    Args:\n        language (str): Programming language (e.g., \"java\", \"python\", \"c\").\n\n    Attributes:\n        language (str): Programming language of the project.\n    \"\"\"\n\n    def __init__(self, language: str):\n        self.language: str = language\n\n    def analysis(\n        self,\n        project_path: str | Path | None = None,\n        source_code: str | None = None,\n        eager: bool = False,\n        analysis_level: str = AnalysisLevel.symbol_table,\n        target_files: List[str] | None = None,\n        analysis_backend_path: str | None = None,\n        analysis_json_path: str | Path = None,\n    ) -&gt; JavaAnalysis | PythonAnalysis | CAnalysis:\n        \"\"\"Initialize a language-specific analysis fa\u00e7ade.\n\n        Args:\n            project_path (str | Path | None): Directory path of the project.\n            source_code (str | None): Source code for single-file analysis.\n            eager (bool): If True, forces regeneration of analysis databases.\n            analysis_level (str): Analysis level. See AnalysisLevel.\n            target_files (list[str] | None): Files to constrain analysis (optional).\n            analysis_backend_path (str | None): Path to the analysis backend.\n            analysis_json_path (str | Path | None): Path to persist analysis database.\n\n        Returns:\n            JavaAnalysis | PythonAnalysis | CAnalysis: Initialized analysis fa\u00e7ade for the chosen language.\n\n        Raises:\n            CldkInitializationException: If both or neither of project_path and source_code are provided.\n            NotImplementedError: If the specified language is unsupported.\n\n        Examples:\n            Initialize Python analysis with inline source code and verify type:\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; cldk = CLDK(language=\"python\")\n            &gt;&gt;&gt; analysis = cldk.analysis(source_code='def f(): return 1')\n            &gt;&gt;&gt; from cldk.analysis.python import PythonAnalysis\n            &gt;&gt;&gt; isinstance(analysis, PythonAnalysis)\n            True\n        \"\"\"\n\n        if project_path is None and source_code is None:\n            raise CldkInitializationException(\"Either project_path or source_code must be provided.\")\n\n        if project_path is not None and source_code is not None:\n            raise CldkInitializationException(\"Both project_path and source_code are provided. Please provide \" \"only one.\")\n\n        if self.language == \"java\":\n            return JavaAnalysis(\n                project_dir=project_path,\n                source_code=source_code,\n                analysis_level=analysis_level,\n                analysis_backend_path=analysis_backend_path,\n                analysis_json_path=analysis_json_path,\n                target_files=target_files,\n                eager_analysis=eager,\n            )\n        elif self.language == \"python\":\n            return PythonAnalysis(\n                project_dir=project_path,\n                source_code=source_code,\n            )\n        elif self.language == \"c\":\n            return CAnalysis(project_dir=project_path)\n        else:\n            raise NotImplementedError(f\"Analysis support for {self.language} is not implemented yet.\")\n\n    def treesitter_parser(self):\n        \"\"\"Return a Treesitter parser for the selected language.\n\n        Returns:\n            TreesitterJava: Parser for Java language.\n\n        Raises:\n            NotImplementedError: If the language is unsupported.\n\n        Examples:\n            Get a Java Treesitter parser:\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; parser = CLDK(language=\"java\").treesitter_parser()\n            &gt;&gt;&gt; parser.__class__.__name__\n            'TreesitterJava'\n        \"\"\"\n        if self.language == \"java\":\n            return TreesitterJava()\n        else:\n            raise NotImplementedError(f\"Treesitter parser for {self.language} is not implemented yet.\")\n\n    def tree_sitter_utils(self, source_code: str) -&gt; [TreesitterSanitizer | NotImplementedError]:  # type: ignore\n        \"\"\"Return Treesitter utilities for the selected language.\n\n        Args:\n            source_code (str): Source code to initialize the utilities with.\n\n        Returns:\n            TreesitterSanitizer: Utility wrapper for Java Treesitter operations.\n\n        Raises:\n            NotImplementedError: If the language is unsupported.\n\n        Examples:\n            Create Java Treesitter sanitizer utilities:\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; utils = CLDK(language=\"java\").tree_sitter_utils('class A {}')\n            &gt;&gt;&gt; from cldk.utils.sanitization.java import TreesitterSanitizer\n            &gt;&gt;&gt; isinstance(utils, TreesitterSanitizer)\n            True\n        \"\"\"\n        if self.language == \"java\":\n            return TreesitterSanitizer(source_code=source_code)\n        else:\n            raise NotImplementedError(f\"Treesitter parser for {self.language} is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/core/#cldk.core.CLDK.analysis","title":"<code>analysis(project_path=None, source_code=None, eager=False, analysis_level=AnalysisLevel.symbol_table, target_files=None, analysis_backend_path=None, analysis_json_path=None)</code>","text":"<p>Initialize a language-specific analysis fa\u00e7ade.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str | Path | None</code> <p>Directory path of the project.</p> <code>None</code> <code>source_code</code> <code>str | None</code> <p>Source code for single-file analysis.</p> <code>None</code> <code>eager</code> <code>bool</code> <p>If True, forces regeneration of analysis databases.</p> <code>False</code> <code>analysis_level</code> <code>str</code> <p>Analysis level. See AnalysisLevel.</p> <code>symbol_table</code> <code>target_files</code> <code>list[str] | None</code> <p>Files to constrain analysis (optional).</p> <code>None</code> <code>analysis_backend_path</code> <code>str | None</code> <p>Path to the analysis backend.</p> <code>None</code> <code>analysis_json_path</code> <code>str | Path | None</code> <p>Path to persist analysis database.</p> <code>None</code> <p>Returns:</p> Type Description <code>JavaAnalysis | PythonAnalysis | CAnalysis</code> <p>JavaAnalysis | PythonAnalysis | CAnalysis: Initialized analysis fa\u00e7ade for the chosen language.</p> <p>Raises:</p> Type Description <code>CldkInitializationException</code> <p>If both or neither of project_path and source_code are provided.</p> <code>NotImplementedError</code> <p>If the specified language is unsupported.</p> <p>Examples:</p> <p>Initialize Python analysis with inline source code and verify type:</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; cldk = CLDK(language=\"python\")\n&gt;&gt;&gt; analysis = cldk.analysis(source_code='def f(): return 1')\n&gt;&gt;&gt; from cldk.analysis.python import PythonAnalysis\n&gt;&gt;&gt; isinstance(analysis, PythonAnalysis)\nTrue\n</code></pre> Source code in <code>cldk/core.py</code> <pre><code>def analysis(\n    self,\n    project_path: str | Path | None = None,\n    source_code: str | None = None,\n    eager: bool = False,\n    analysis_level: str = AnalysisLevel.symbol_table,\n    target_files: List[str] | None = None,\n    analysis_backend_path: str | None = None,\n    analysis_json_path: str | Path = None,\n) -&gt; JavaAnalysis | PythonAnalysis | CAnalysis:\n    \"\"\"Initialize a language-specific analysis fa\u00e7ade.\n\n    Args:\n        project_path (str | Path | None): Directory path of the project.\n        source_code (str | None): Source code for single-file analysis.\n        eager (bool): If True, forces regeneration of analysis databases.\n        analysis_level (str): Analysis level. See AnalysisLevel.\n        target_files (list[str] | None): Files to constrain analysis (optional).\n        analysis_backend_path (str | None): Path to the analysis backend.\n        analysis_json_path (str | Path | None): Path to persist analysis database.\n\n    Returns:\n        JavaAnalysis | PythonAnalysis | CAnalysis: Initialized analysis fa\u00e7ade for the chosen language.\n\n    Raises:\n        CldkInitializationException: If both or neither of project_path and source_code are provided.\n        NotImplementedError: If the specified language is unsupported.\n\n    Examples:\n        Initialize Python analysis with inline source code and verify type:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; cldk = CLDK(language=\"python\")\n        &gt;&gt;&gt; analysis = cldk.analysis(source_code='def f(): return 1')\n        &gt;&gt;&gt; from cldk.analysis.python import PythonAnalysis\n        &gt;&gt;&gt; isinstance(analysis, PythonAnalysis)\n        True\n    \"\"\"\n\n    if project_path is None and source_code is None:\n        raise CldkInitializationException(\"Either project_path or source_code must be provided.\")\n\n    if project_path is not None and source_code is not None:\n        raise CldkInitializationException(\"Both project_path and source_code are provided. Please provide \" \"only one.\")\n\n    if self.language == \"java\":\n        return JavaAnalysis(\n            project_dir=project_path,\n            source_code=source_code,\n            analysis_level=analysis_level,\n            analysis_backend_path=analysis_backend_path,\n            analysis_json_path=analysis_json_path,\n            target_files=target_files,\n            eager_analysis=eager,\n        )\n    elif self.language == \"python\":\n        return PythonAnalysis(\n            project_dir=project_path,\n            source_code=source_code,\n        )\n    elif self.language == \"c\":\n        return CAnalysis(project_dir=project_path)\n    else:\n        raise NotImplementedError(f\"Analysis support for {self.language} is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/core/#cldk.core.CLDK.treesitter_parser","title":"<code>treesitter_parser()</code>","text":"<p>Return a Treesitter parser for the selected language.</p> <p>Returns:</p> Name Type Description <code>TreesitterJava</code> <p>Parser for Java language.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the language is unsupported.</p> <p>Examples:</p> <p>Get a Java Treesitter parser:</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; parser = CLDK(language=\"java\").treesitter_parser()\n&gt;&gt;&gt; parser.__class__.__name__\n'TreesitterJava'\n</code></pre> Source code in <code>cldk/core.py</code> <pre><code>def treesitter_parser(self):\n    \"\"\"Return a Treesitter parser for the selected language.\n\n    Returns:\n        TreesitterJava: Parser for Java language.\n\n    Raises:\n        NotImplementedError: If the language is unsupported.\n\n    Examples:\n        Get a Java Treesitter parser:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; parser = CLDK(language=\"java\").treesitter_parser()\n        &gt;&gt;&gt; parser.__class__.__name__\n        'TreesitterJava'\n    \"\"\"\n    if self.language == \"java\":\n        return TreesitterJava()\n    else:\n        raise NotImplementedError(f\"Treesitter parser for {self.language} is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/core/#cldk.core.CLDK.tree_sitter_utils","title":"<code>tree_sitter_utils(source_code)</code>","text":"<p>Return Treesitter utilities for the selected language.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to initialize the utilities with.</p> required <p>Returns:</p> Name Type Description <code>TreesitterSanitizer</code> <code>[TreesitterSanitizer | NotImplementedError]</code> <p>Utility wrapper for Java Treesitter operations.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the language is unsupported.</p> <p>Examples:</p> <p>Create Java Treesitter sanitizer utilities:</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; utils = CLDK(language=\"java\").tree_sitter_utils('class A {}')\n&gt;&gt;&gt; from cldk.utils.sanitization.java import TreesitterSanitizer\n&gt;&gt;&gt; isinstance(utils, TreesitterSanitizer)\nTrue\n</code></pre> Source code in <code>cldk/core.py</code> <pre><code>def tree_sitter_utils(self, source_code: str) -&gt; [TreesitterSanitizer | NotImplementedError]:  # type: ignore\n    \"\"\"Return Treesitter utilities for the selected language.\n\n    Args:\n        source_code (str): Source code to initialize the utilities with.\n\n    Returns:\n        TreesitterSanitizer: Utility wrapper for Java Treesitter operations.\n\n    Raises:\n        NotImplementedError: If the language is unsupported.\n\n    Examples:\n        Create Java Treesitter sanitizer utilities:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; utils = CLDK(language=\"java\").tree_sitter_utils('class A {}')\n        &gt;&gt;&gt; from cldk.utils.sanitization.java import TreesitterSanitizer\n        &gt;&gt;&gt; isinstance(utils, TreesitterSanitizer)\n        True\n    \"\"\"\n    if self.language == \"java\":\n        return TreesitterSanitizer(source_code=source_code)\n    else:\n        raise NotImplementedError(f\"Treesitter parser for {self.language} is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/","title":"Java API","text":""},{"location":"reference/python-api/java/#analysis","title":"Analysis","text":"<p>Java analysis utilities.</p> <p>Provides a high-level API to analyze Java projects or single-source inputs using a Treesitter-based parser and the Code Analyzer backend.</p>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis","title":"<code>JavaAnalysis</code>","text":"<p>Analysis fa\u00e7ade for Java code.</p> <p>This class exposes methods to query symbol tables, classes, methods, call graphs, comments, and CRUD operations for a Java project or a single source file, depending on the initialization parameters.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>class JavaAnalysis:\n    \"\"\"Analysis fa\u00e7ade for Java code.\n\n    This class exposes methods to query symbol tables, classes, methods,\n    call graphs, comments, and CRUD operations for a Java project or a single\n    source file, depending on the initialization parameters.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_dir: str | Path | None,\n        source_code: str | None,\n        analysis_backend_path: str | None,\n        analysis_json_path: str | Path | None,\n        analysis_level: str,\n        target_files: List[str] | None,\n        eager_analysis: bool,\n    ) -&gt; None:\n        \"\"\"Initialize the Java analysis backend.\n\n        Args:\n            project_dir (str | Path | None): Directory path of the project.\n            source_code (str | None): Source text for single-file analysis.\n            analysis_backend_path (str | None): Path to the analysis backend. For\n                CodeQL, the CLI must be installed and on PATH. For CodeAnalyzer,\n                the JAR is downloaded from the latest release when not provided.\n            analysis_json_path (str | Path | None): Path to persist the analysis\n                database (analysis.json). If None, results are not persisted.\n            analysis_level (str): Analysis level. For example, \"symbol-table\" or\n                \"call-graph\".\n            target_files (list[str] | None): Optional list of target file paths to\n                constrain analysis (primarily supported for symbol-table).\n            eager_analysis (bool): If True, forces regeneration of analysis.json\n                on each run even if it exists.\n\n        Raises:\n            NotImplementedError: If the requested analysis backend is unsupported.\n        \"\"\"\n\n        self.project_dir = project_dir\n        self.source_code = source_code\n        self.analysis_level = analysis_level\n        self.analysis_json_path = analysis_json_path\n        self.analysis_backend_path = analysis_backend_path\n        self.eager_analysis = eager_analysis\n        self.target_files = target_files\n        self.treesitter_java: TreesitterJava = TreesitterJava()\n        # Initialize the analysis analysis_backend\n        self.backend: JCodeanalyzer = JCodeanalyzer(\n            project_dir=self.project_dir,\n            source_code=self.source_code,\n            eager_analysis=self.eager_analysis,\n            analysis_level=self.analysis_level,\n            analysis_json_path=self.analysis_json_path,\n            analysis_backend_path=self.analysis_backend_path,\n            target_files=self.target_files,\n        )\n\n    def get_imports(self) -&gt; List[str]:\n        \"\"\"Return all import statements in the source code.\n\n        Returns:\n            list[str]: All import statements.\n\n        Raises:\n            NotImplementedError: If this functionality is not supported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_variables(self, **kwargs):\n        \"\"\"Return all variables discovered in the source code.\n\n        Returns:\n            Any: Implementation-defined variable view.\n\n        Raises:\n            NotImplementedError: If this functionality is not supported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_service_entry_point_classes(self, **kwargs):\n        \"\"\"Return all service entry-point classes.\n\n        Returns:\n            Any: Implementation-defined list or mapping of service classes.\n\n        Raises:\n            NotImplementedError: If this functionality is not supported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_service_entry_point_methods(self, **kwargs):\n        \"\"\"Return all service entry-point methods.\n\n        Returns:\n            Any: Implementation-defined list or mapping of service methods.\n\n        Raises:\n            NotImplementedError: If this functionality is not supported.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_application_view(self) -&gt; JApplication:\n        \"\"\"Return the application view of the Java code.\n\n        Returns:\n            JApplication: Application view of the Java code.\n\n        Raises:\n            NotImplementedError: If single-file mode is used (unsupported here).\n\n        Examples:\n            Get an application view using a project directory (backend required):\n\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.symbol_table,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; isinstance(ja.source_code, type(None))\n            True\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n        return self.backend.get_application_view()\n\n    def get_symbol_table(self) -&gt; Dict[str, JCompilationUnit]:\n        \"\"\"Return the symbol table.\n\n        Returns:\n            dict[str, JCompilationUnit]: Symbol table keyed by file path.\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.symbol_table,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; isinstance(ja.get_symbol_table(), dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_symbol_table()\n\n    def get_compilation_units(self) -&gt; List[JCompilationUnit]:\n        \"\"\"Return all compilation units in the Java code.\n\n        Returns:\n            list[JCompilationUnit]: Compilation units of the Java code.\n\n        Examples:\n            List all compilation units for a project (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; isinstance(ja.get_compilation_units(), list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_compilation_units()\n\n    def get_class_hierarchy(self) -&gt; nx.DiGraph:\n        \"\"\"Return the class hierarchy of the Java code.\n\n        Returns:\n            networkx.DiGraph: Class hierarchy.\n\n        Raises:\n            NotImplementedError: Always, as the feature is not implemented yet.\n        \"\"\"\n\n        raise NotImplementedError(\"Class hierarchy is not implemented yet.\")\n\n    def is_parsable(self, source_code: str) -&gt; bool:\n        \"\"\"Check if the source code is parsable.\n\n        Args:\n            source_code (str): Source code to parse.\n\n        Returns:\n            bool: True if parsable, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; src = 'class A { void f(){} }'\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n            &gt;&gt;&gt; ja.is_parsable(src)\n            True\n        \"\"\"\n        return self.treesitter_java.is_parsable(source_code)\n\n    def get_raw_ast(self, source_code: str) -&gt; Tree:\n        \"\"\"Parse and return the raw AST.\n\n        Args:\n            source_code (str): Source code to parse.\n\n        Returns:\n            Tree: Raw syntax tree.\n\n        Examples:\n            &gt;&gt;&gt; src = 'class A { void f(){} }'\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n            &gt;&gt;&gt; ast = ja.get_raw_ast(src)\n            &gt;&gt;&gt; ast.root_node is not None\n            True\n        \"\"\"\n        return self.treesitter_java.get_raw_ast(source_code)\n\n    def get_call_graph(self) -&gt; nx.DiGraph:\n        \"\"\"Return the call graph of the Java code.\n\n        Returns:\n            networkx.DiGraph: Call graph.\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.call_graph,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; isinstance(ja.get_call_graph(), nx.DiGraph)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_call_graph()\n\n    def get_call_graph_json(self) -&gt; str:\n        \"\"\"Return the call graph serialized as JSON.\n\n        Returns:\n            str: Call graph encoded as JSON.\n\n        Raises:\n            NotImplementedError: If single-file mode is used (unsupported here).\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.call_graph,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; isinstance(ja.get_call_graph_json(), str)  # doctest: +SKIP\n            True\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n        return self.backend.get_call_graph_json()\n\n    def get_callers(self, target_class_name: str, target_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n        \"\"\"Return all callers of a target method.\n\n        Args:\n            target_class_name (str): Qualified name of the target class.\n            target_method_declaration (str): Target method signature.\n            using_symbol_table (bool): Whether to use the symbol table. Defaults to False.\n\n        Returns:\n            dict: Mapping of callers to call sites/details.\n\n        Raises:\n            NotImplementedError: If single-file mode is used (unsupported here).\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.call_graph,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; callers = ja.get_callers('com.example.A', 'f()')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(callers, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n\n        if self.source_code:\n            raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n        return self.backend.get_all_callers(target_class_name, target_method_declaration, using_symbol_table)\n\n    def get_callees(self, source_class_name: str, source_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n        \"\"\"Return all callees of a given method.\n\n        Args:\n            source_class_name (str): Qualified class name containing the method.\n            source_method_declaration (str): Method signature.\n            using_symbol_table (bool): Whether to use the symbol table. Defaults to False.\n\n        Returns:\n            dict: Mapping of callees to call sites/details.\n\n        Raises:\n            NotImplementedError: If single-file mode is used (unsupported here).\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.call_graph,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; callees = ja.get_callees('com.example.A', 'f()')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(callees, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        if self.source_code:\n            raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n        return self.backend.get_all_callees(source_class_name, source_method_declaration, using_symbol_table)\n\n    def get_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n        \"\"\"Return all methods in the Java code.\n\n        Returns:\n            dict[str, dict[str, JCallable]]: Methods grouped by qualified class name.\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.symbol_table,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; methods = ja.get_methods()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(methods, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_methods_in_application()\n\n    def get_classes(self) -&gt; Dict[str, JType]:\n        \"\"\"Return all classes in the Java code.\n\n        Returns:\n            dict[str, JType]: Classes keyed by qualified class name.\n\n        Examples:\n            &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n            &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n            ...                  analysis_backend_path=None, analysis_json_path=None,\n            ...                  analysis_level=AnalysisLevel.symbol_table,\n            ...                  target_files=None, eager_analysis=False)\n            &gt;&gt;&gt; classes = ja.get_classes()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(classes, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_classes()\n\n    def get_classes_by_criteria(self, inclusions=None, exclusions=None) -&gt; Dict[str, JType]:\n        \"\"\"Return classes filtered by simple inclusion/exclusion criteria.\n\n        Args:\n            inclusions (list[str] | None): If provided, only classes whose name\n                contains any of these substrings are included.\n            exclusions (list[str] | None): If provided, classes whose name contains\n                any of these substrings are excluded.\n\n        Returns:\n            dict[str, JType]: Matching classes keyed by qualified class name.\n\n        Examples:\n            Filter classes using simple contains checks (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; filtered = ja.get_classes_by_criteria(inclusions=['Service'], exclusions=['Test'])  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(filtered, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        if exclusions is None:\n            exclusions = []\n        if inclusions is None:\n            inclusions = []\n        class_dict: Dict[str, JType] = {}\n        all_classes = self.backend.get_all_classes()\n        for application_class in all_classes:\n            is_selected = False\n            for inclusion in inclusions:\n                if inclusion in application_class:\n                    is_selected = True\n\n            for exclusion in exclusions:\n                if exclusion in application_class:\n                    is_selected = False\n            if is_selected:\n                class_dict[application_class] = all_classes[application_class]\n        return class_dict\n\n    def get_class(self, qualified_class_name: str) -&gt; JType:\n        \"\"\"Return a class object.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            JType: Class object for the given class.\n\n        Examples:\n            Look up a class by its qualified name (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; c = ja.get_class('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; c is not None  # doctest: +SKIP\n            True\n        \"\"\"\n\n        return self.backend.get_class(qualified_class_name)\n\n    def get_method(self, qualified_class_name: str, qualified_method_name: str) -&gt; JCallable:\n        \"\"\"Return a method object.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n            qualified_method_name (str): Qualified method name.\n\n        Returns:\n            JCallable: Method object.\n\n        Examples:\n            Look up a method by its qualified signature (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; m = ja.get_method('com.example.A', 'f()')  # doctest: +SKIP\n            &gt;&gt;&gt; m is not None  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_method(qualified_class_name, qualified_method_name)\n\n    def get_method_parameters(self, qualified_class_name: str, qualified_method_name: str) -&gt; List[str]:\n        \"\"\"Return the parameter types/names for a method.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n            qualified_method_name (str): Qualified method name.\n\n        Returns:\n            list[str]: Method parameters.\n\n        Examples:\n            List parameters for a method (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; params = ja.get_method_parameters('com.example.A', 'g(int, java.lang.String)')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(params, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_method_parameters(qualified_class_name, qualified_method_name)\n\n    def get_java_file(self, qualified_class_name: str) -&gt; str:\n        \"\"\"Return the Java file path containing a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            str: Path to the Java file.\n\n        Examples:\n            Get the source file path for a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; path = ja.get_java_file('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(path, str)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_java_file(qualified_class_name)\n\n    def get_java_compilation_unit(self, file_path: str) -&gt; JCompilationUnit:\n        \"\"\"Return the compilation unit for a Java source file.\n\n        Args:\n            file_path (str): Absolute path to a Java source file.\n\n        Returns:\n            JCompilationUnit: Compilation unit object.\n\n        Examples:\n            Parse a Java file into a compilation unit (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; cu = ja.get_java_compilation_unit('/abs/path/to/A.java')  # doctest: +SKIP\n            &gt;&gt;&gt; cu is not None  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_java_compilation_unit(file_path)\n\n    def get_methods_in_class(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n        \"\"\"Return all methods of a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            dict[str, JCallable]: Methods keyed by signature.\n\n        Examples:\n            List methods declared in a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; methods = ja.get_methods_in_class('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(methods, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_methods_in_class(qualified_class_name)\n\n    def get_constructors(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n        \"\"\"Return all constructors of a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            dict[str, JCallable]: Constructors keyed by signature.\n\n        Examples:\n            List constructors declared in a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; ctors = ja.get_constructors('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(ctors, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_constructors(qualified_class_name)\n\n    def get_fields(self, qualified_class_name) -&gt; List[JField]:\n        \"\"\"Return all fields of a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            list[JField]: All fields of the class.\n\n        Examples:\n            List fields declared in a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; fields = ja.get_fields('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(fields, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_fields(qualified_class_name)\n\n    def get_nested_classes(self, qualified_class_name) -&gt; List[JType]:\n        \"\"\"Return all nested classes of a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            list[JType]: Nested classes.\n\n        Examples:\n            List nested classes declared in a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; nested = ja.get_nested_classes('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(nested, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_nested_classes(qualified_class_name)\n\n    def get_sub_classes(self, qualified_class_name) -&gt; Dict[str, JType]:\n        \"\"\"Return all subclasses of a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            dict[str, JType]: Subclasses keyed by qualified name.\n\n        Examples:\n            List subclasses of a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; subs = ja.get_sub_classes('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(subs, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_sub_classes(qualified_class_name=qualified_class_name)\n\n    def get_extended_classes(self, qualified_class_name) -&gt; List[str]:\n        \"\"\"Return all extended superclasses for a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            list[str]: Extended classes.\n\n        Examples:\n            List extended classes for a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; supers = ja.get_extended_classes('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(supers, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_extended_classes(qualified_class_name)\n\n    def get_implemented_interfaces(self, qualified_class_name: str) -&gt; List[str]:\n        \"\"\"Return all implemented interfaces for a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            list[str]: Implemented interfaces.\n\n        Examples:\n            List implemented interfaces for a class (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; ifaces = ja.get_implemented_interfaces('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(ifaces, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_implemented_interfaces(qualified_class_name)\n\n    def __get_class_call_graph_using_symbol_table(self, qualified_class_name: str, method_signature: str | None = None) -&gt; (List)[Tuple[JMethodDetail, JMethodDetail]]:\n        \"\"\"Return class-level call graph using the symbol table.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n            method_signature (str | None): Optional method signature to scope the graph.\n\n        Returns:\n            list[tuple[JMethodDetail, JMethodDetail]]: Edge list of caller -&gt; callee.\n        \"\"\"\n        return self.backend.get_class_call_graph_using_symbol_table(qualified_class_name, method_signature)\n\n    def get_class_call_graph(self, qualified_class_name: str, method_signature: str | None = None, using_symbol_table: bool = False) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]:\n        \"\"\"Return a class-level call graph.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n            method_signature (str | None): Optional method signature to scope the graph.\n            using_symbol_table (bool): If True, use the symbol table for resolution.\n\n        Returns:\n            list[tuple[JMethodDetail, JMethodDetail]]: Edge list of caller -&gt; callee.\n\n        Examples:\n            Build a class-level call graph (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project', analysis_level='call-graph')\n            &gt;&gt;&gt; edges = ja.get_class_call_graph('com.example.A')  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(edges, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        if using_symbol_table:\n            return self.__get_class_call_graph_using_symbol_table(qualified_class_name=qualified_class_name, method_signature=method_signature)\n        return self.backend.get_class_call_graph(qualified_class_name, method_signature)\n\n    def get_entry_point_classes(self) -&gt; Dict[str, JType]:\n        \"\"\"Return all entry-point classes.\n\n        Returns:\n            dict[str, JType]: Entry-point classes keyed by qualified class name.\n\n        Examples:\n            List entry-point classes in an application (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; eps = ja.get_entry_point_classes()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(eps, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_entry_point_classes()\n\n    def get_entry_point_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n        \"\"\"Return all entry-point methods grouped by class.\n\n        Returns:\n            dict[str, dict[str, JCallable]]: Entry-point methods keyed by class.\n\n        Examples:\n            List entry-point methods in an application (backend required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; epms = ja.get_entry_point_methods()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(epms, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_entry_point_methods()\n\n    def remove_all_comments(self) -&gt; str:\n        \"\"\"Remove all comments from the source code.\n\n        Returns:\n            str: Source code with comments removed.\n\n        Examples:\n            Remove comments from inline source code:\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; src = 'class A { /* c */ // d\\n void f(){} }'.replace('\\n', ' ')\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n            &gt;&gt;&gt; cleaned = ja.remove_all_comments()  # doctest: +SKIP\n            &gt;&gt;&gt; '/*' in cleaned or '//' in cleaned  # doctest: +SKIP\n            False\n        \"\"\"\n        return self.backend.remove_all_comments(self.source_code)\n\n    def get_methods_with_annotations(self, annotations: List[str]) -&gt; Dict[str, List[Dict]]:\n        \"\"\"Return methods grouped by the given annotations.\n\n        Args:\n            annotations (list[str]): Annotations to search for.\n\n        Returns:\n            dict[str, list[dict]]: Methods and bodies keyed by annotation.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n        \"\"\"\n        # TODO: This call is missing some implementation. The logic currently resides in java_sitter but tree_sitter will no longer be option, rather it will be default and common. Need to implement this differently. Somthing like, self.commons.treesitter.get_methods_with_annotations(annotations)\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_test_methods(self) -&gt; Dict[str, str]:\n        \"\"\"Return test methods discovered in the source code.\n\n        Returns:\n            dict[str, str]: Mapping of method signature to body.\n\n        Examples:\n            Extract test methods from inline source code:\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; src = 'import org.junit.Test; class A { @Test public void t(){} }'\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n            &gt;&gt;&gt; tests = ja.get_test_methods()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(tests, dict)  # doctest: +SKIP\n            True\n        \"\"\"\n\n        return self.treesitter_java.get_test_methods(source_class_code=self.source_code)\n\n    def get_calling_lines(self, target_method_name: str) -&gt; List[int]:\n        \"\"\"Return line numbers where a target method is called within a method body.\n\n        Args:\n            target_method_name (str): Target method name.\n\n        Returns:\n            list[int]: Line numbers within the source method code block.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_call_targets(self, declared_methods: dict) -&gt; Set[str]:\n        \"\"\"Return call targets using simple name resolution over the AST.\n\n        Args:\n            declared_methods (dict): All methods declared in the class.\n\n        Returns:\n            set[str]: Discovered call targets.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_all_crud_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n        \"\"\"Return all CRUD operations in the source code.\n\n        Returns:\n            list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: CRUD operations grouped by class/method.\n\n        Examples:\n            Get all CRUD operations discovered by the backend (project required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; ops = ja.get_all_crud_operations()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(ops, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_crud_operations()\n\n    def get_all_create_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n        \"\"\"Return all create operations in the source code.\n\n        Returns:\n            list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Create operations.\n\n        Examples:\n            Get create operations (project required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; creates = ja.get_all_create_operations()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(creates, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_create_operations()\n\n    def get_all_read_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n        \"\"\"Return all read operations in the source code.\n\n        Returns:\n            list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Read operations.\n\n        Examples:\n            Get read operations (project required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; reads = ja.get_all_read_operations()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(reads, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_read_operations()\n\n    def get_all_update_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n        \"\"\"Return all update operations in the source code.\n\n        Returns:\n            list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Update operations.\n\n        Examples:\n            Get update operations (project required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; updates = ja.get_all_update_operations()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(updates, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_update_operations()\n\n    def get_all_delete_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n        \"\"\"Return all delete operations in the source code.\n\n        Returns:\n            list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Delete operations.\n\n        Examples:\n            Get delete operations (project required):\n\n            &gt;&gt;&gt; from cldk import CLDK\n            &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n            &gt;&gt;&gt; deletes = ja.get_all_delete_operations()  # doctest: +SKIP\n            &gt;&gt;&gt; isinstance(deletes, list)  # doctest: +SKIP\n            True\n        \"\"\"\n        return self.backend.get_all_delete_operations()\n\n    # Some APIs to process comments\n    def get_comments_in_a_method(self, qualified_class_name: str, method_signature: str) -&gt; List[JComment]:\n        \"\"\"Return all comments in a method.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n            method_signature (str): Method signature.\n\n        Returns:\n            list[JComment]: Comments in the method.\n        \"\"\"\n        return self.backend.get_comments_in_a_method(qualified_class_name, method_signature)\n\n    def get_comments_in_a_class(self, qualified_class_name: str) -&gt; List[JComment]:\n        \"\"\"Return all comments in a class.\n\n        Args:\n            qualified_class_name (str): Qualified class name.\n\n        Returns:\n            list[JComment]: Comments in the class.\n        \"\"\"\n        return self.backend.get_comments_in_a_class(qualified_class_name)\n\n    def get_comment_in_file(self, file_path: str) -&gt; List[JComment]:\n        \"\"\"Return all comments in a file.\n\n        Args:\n            file_path (str): Absolute file path.\n\n        Returns:\n            list[JComment]: Comments in the file.\n        \"\"\"\n        return self.backend.get_comment_in_file(file_path)\n\n    def get_all_comments(self) -&gt; Dict[str, List[JComment]]:\n        \"\"\"Return all comments grouped by file.\n\n        Returns:\n            dict[str, list[JComment]]: Mapping of file path to comments.\n        \"\"\"\n        return self.backend.get_all_comments()\n\n    def get_all_docstrings(self) -&gt; Dict[str, List[JComment]]:\n        \"\"\"Return all docstrings grouped by file.\n\n        Returns:\n            dict[str, list[JComment]]: Mapping of file path to docstrings.\n        \"\"\"\n        return self.backend.get_all_docstrings()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_imports","title":"<code>get_imports()</code>","text":"<p>Return all import statements in the source code.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: All import statements.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this functionality is not supported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_imports(self) -&gt; List[str]:\n    \"\"\"Return all import statements in the source code.\n\n    Returns:\n        list[str]: All import statements.\n\n    Raises:\n        NotImplementedError: If this functionality is not supported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_variables","title":"<code>get_variables(**kwargs)</code>","text":"<p>Return all variables discovered in the source code.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>Implementation-defined variable view.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this functionality is not supported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_variables(self, **kwargs):\n    \"\"\"Return all variables discovered in the source code.\n\n    Returns:\n        Any: Implementation-defined variable view.\n\n    Raises:\n        NotImplementedError: If this functionality is not supported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_service_entry_point_classes","title":"<code>get_service_entry_point_classes(**kwargs)</code>","text":"<p>Return all service entry-point classes.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>Implementation-defined list or mapping of service classes.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this functionality is not supported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_service_entry_point_classes(self, **kwargs):\n    \"\"\"Return all service entry-point classes.\n\n    Returns:\n        Any: Implementation-defined list or mapping of service classes.\n\n    Raises:\n        NotImplementedError: If this functionality is not supported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_service_entry_point_methods","title":"<code>get_service_entry_point_methods(**kwargs)</code>","text":"<p>Return all service entry-point methods.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>Implementation-defined list or mapping of service methods.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this functionality is not supported.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_service_entry_point_methods(self, **kwargs):\n    \"\"\"Return all service entry-point methods.\n\n    Returns:\n        Any: Implementation-defined list or mapping of service methods.\n\n    Raises:\n        NotImplementedError: If this functionality is not supported.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_application_view","title":"<code>get_application_view()</code>","text":"<p>Return the application view of the Java code.</p> <p>Returns:</p> Name Type Description <code>JApplication</code> <code>JApplication</code> <p>Application view of the Java code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If single-file mode is used (unsupported here).</p> <p>Examples:</p> <p>Get an application view using a project directory (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.symbol_table,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; isinstance(ja.source_code, type(None))\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_application_view(self) -&gt; JApplication:\n    \"\"\"Return the application view of the Java code.\n\n    Returns:\n        JApplication: Application view of the Java code.\n\n    Raises:\n        NotImplementedError: If single-file mode is used (unsupported here).\n\n    Examples:\n        Get an application view using a project directory (backend required):\n\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.symbol_table,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; isinstance(ja.source_code, type(None))\n        True\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n    return self.backend.get_application_view()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_symbol_table","title":"<code>get_symbol_table()</code>","text":"<p>Return the symbol table.</p> <p>Returns:</p> Type Description <code>Dict[str, JCompilationUnit]</code> <p>dict[str, JCompilationUnit]: Symbol table keyed by file path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.symbol_table,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; isinstance(ja.get_symbol_table(), dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_symbol_table(self) -&gt; Dict[str, JCompilationUnit]:\n    \"\"\"Return the symbol table.\n\n    Returns:\n        dict[str, JCompilationUnit]: Symbol table keyed by file path.\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.symbol_table,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; isinstance(ja.get_symbol_table(), dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_symbol_table()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_compilation_units","title":"<code>get_compilation_units()</code>","text":"<p>Return all compilation units in the Java code.</p> <p>Returns:</p> Type Description <code>List[JCompilationUnit]</code> <p>list[JCompilationUnit]: Compilation units of the Java code.</p> <p>Examples:</p> <p>List all compilation units for a project (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; isinstance(ja.get_compilation_units(), list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_compilation_units(self) -&gt; List[JCompilationUnit]:\n    \"\"\"Return all compilation units in the Java code.\n\n    Returns:\n        list[JCompilationUnit]: Compilation units of the Java code.\n\n    Examples:\n        List all compilation units for a project (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; isinstance(ja.get_compilation_units(), list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_compilation_units()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_class_hierarchy","title":"<code>get_class_hierarchy()</code>","text":"<p>Return the class hierarchy of the Java code.</p> <p>Returns:</p> Type Description <code>DiGraph</code> <p>networkx.DiGraph: Class hierarchy.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as the feature is not implemented yet.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class_hierarchy(self) -&gt; nx.DiGraph:\n    \"\"\"Return the class hierarchy of the Java code.\n\n    Returns:\n        networkx.DiGraph: Class hierarchy.\n\n    Raises:\n        NotImplementedError: Always, as the feature is not implemented yet.\n    \"\"\"\n\n    raise NotImplementedError(\"Class hierarchy is not implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.is_parsable","title":"<code>is_parsable(source_code)</code>","text":"<p>Check if the source code is parsable.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to parse.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if parsable, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'class A { void f(){} }'\n&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n&gt;&gt;&gt; ja.is_parsable(src)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def is_parsable(self, source_code: str) -&gt; bool:\n    \"\"\"Check if the source code is parsable.\n\n    Args:\n        source_code (str): Source code to parse.\n\n    Returns:\n        bool: True if parsable, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; src = 'class A { void f(){} }'\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n        &gt;&gt;&gt; ja.is_parsable(src)\n        True\n    \"\"\"\n    return self.treesitter_java.is_parsable(source_code)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_raw_ast","title":"<code>get_raw_ast(source_code)</code>","text":"<p>Parse and return the raw AST.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to parse.</p> required <p>Returns:</p> Name Type Description <code>Tree</code> <code>Tree</code> <p>Raw syntax tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'class A { void f(){} }'\n&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n&gt;&gt;&gt; ast = ja.get_raw_ast(src)\n&gt;&gt;&gt; ast.root_node is not None\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_raw_ast(self, source_code: str) -&gt; Tree:\n    \"\"\"Parse and return the raw AST.\n\n    Args:\n        source_code (str): Source code to parse.\n\n    Returns:\n        Tree: Raw syntax tree.\n\n    Examples:\n        &gt;&gt;&gt; src = 'class A { void f(){} }'\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n        &gt;&gt;&gt; ast = ja.get_raw_ast(src)\n        &gt;&gt;&gt; ast.root_node is not None\n        True\n    \"\"\"\n    return self.treesitter_java.get_raw_ast(source_code)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_call_graph","title":"<code>get_call_graph()</code>","text":"<p>Return the call graph of the Java code.</p> <p>Returns:</p> Type Description <code>DiGraph</code> <p>networkx.DiGraph: Call graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.call_graph,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; isinstance(ja.get_call_graph(), nx.DiGraph)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_graph(self) -&gt; nx.DiGraph:\n    \"\"\"Return the call graph of the Java code.\n\n    Returns:\n        networkx.DiGraph: Call graph.\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.call_graph,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; isinstance(ja.get_call_graph(), nx.DiGraph)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_call_graph()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_call_graph_json","title":"<code>get_call_graph_json()</code>","text":"<p>Return the call graph serialized as JSON.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Call graph encoded as JSON.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If single-file mode is used (unsupported here).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.call_graph,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; isinstance(ja.get_call_graph_json(), str)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_graph_json(self) -&gt; str:\n    \"\"\"Return the call graph serialized as JSON.\n\n    Returns:\n        str: Call graph encoded as JSON.\n\n    Raises:\n        NotImplementedError: If single-file mode is used (unsupported here).\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.call_graph,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; isinstance(ja.get_call_graph_json(), str)  # doctest: +SKIP\n        True\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Producing a call graph over a single file is not implemented yet.\")\n    return self.backend.get_call_graph_json()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_callers","title":"<code>get_callers(target_class_name, target_method_declaration, using_symbol_table=False)</code>","text":"<p>Return all callers of a target method.</p> <p>Parameters:</p> Name Type Description Default <code>target_class_name</code> <code>str</code> <p>Qualified name of the target class.</p> required <code>target_method_declaration</code> <code>str</code> <p>Target method signature.</p> required <code>using_symbol_table</code> <code>bool</code> <p>Whether to use the symbol table. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Mapping of callers to call sites/details.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If single-file mode is used (unsupported here).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.call_graph,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; callers = ja.get_callers('com.example.A', 'f()')\n&gt;&gt;&gt; isinstance(callers, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_callers(self, target_class_name: str, target_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n    \"\"\"Return all callers of a target method.\n\n    Args:\n        target_class_name (str): Qualified name of the target class.\n        target_method_declaration (str): Target method signature.\n        using_symbol_table (bool): Whether to use the symbol table. Defaults to False.\n\n    Returns:\n        dict: Mapping of callers to call sites/details.\n\n    Raises:\n        NotImplementedError: If single-file mode is used (unsupported here).\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.call_graph,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; callers = ja.get_callers('com.example.A', 'f()')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(callers, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n\n    if self.source_code:\n        raise NotImplementedError(\"Generating all callers over a single file is not implemented yet.\")\n    return self.backend.get_all_callers(target_class_name, target_method_declaration, using_symbol_table)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_callees","title":"<code>get_callees(source_class_name, source_method_declaration, using_symbol_table=False)</code>","text":"<p>Return all callees of a given method.</p> <p>Parameters:</p> Name Type Description Default <code>source_class_name</code> <code>str</code> <p>Qualified class name containing the method.</p> required <code>source_method_declaration</code> <code>str</code> <p>Method signature.</p> required <code>using_symbol_table</code> <code>bool</code> <p>Whether to use the symbol table. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>Mapping of callees to call sites/details.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If single-file mode is used (unsupported here).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.call_graph,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; callees = ja.get_callees('com.example.A', 'f()')\n&gt;&gt;&gt; isinstance(callees, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_callees(self, source_class_name: str, source_method_declaration: str, using_symbol_table: bool = False) -&gt; Dict:\n    \"\"\"Return all callees of a given method.\n\n    Args:\n        source_class_name (str): Qualified class name containing the method.\n        source_method_declaration (str): Method signature.\n        using_symbol_table (bool): Whether to use the symbol table. Defaults to False.\n\n    Returns:\n        dict: Mapping of callees to call sites/details.\n\n    Raises:\n        NotImplementedError: If single-file mode is used (unsupported here).\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.call_graph,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; callees = ja.get_callees('com.example.A', 'f()')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(callees, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    if self.source_code:\n        raise NotImplementedError(\"Generating all callees over a single file is not implemented yet.\")\n    return self.backend.get_all_callees(source_class_name, source_method_declaration, using_symbol_table)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_methods","title":"<code>get_methods()</code>","text":"<p>Return all methods in the Java code.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, JCallable]]</code> <p>dict[str, dict[str, JCallable]]: Methods grouped by qualified class name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.symbol_table,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; methods = ja.get_methods()\n&gt;&gt;&gt; isinstance(methods, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n    \"\"\"Return all methods in the Java code.\n\n    Returns:\n        dict[str, dict[str, JCallable]]: Methods grouped by qualified class name.\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.symbol_table,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; methods = ja.get_methods()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(methods, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_methods_in_application()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_classes","title":"<code>get_classes()</code>","text":"<p>Return all classes in the Java code.</p> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>dict[str, JType]: Classes keyed by qualified class name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n&gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n...                  analysis_backend_path=None, analysis_json_path=None,\n...                  analysis_level=AnalysisLevel.symbol_table,\n...                  target_files=None, eager_analysis=False)\n&gt;&gt;&gt; classes = ja.get_classes()\n&gt;&gt;&gt; isinstance(classes, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_classes(self) -&gt; Dict[str, JType]:\n    \"\"\"Return all classes in the Java code.\n\n    Returns:\n        dict[str, JType]: Classes keyed by qualified class name.\n\n    Examples:\n        &gt;&gt;&gt; from cldk.analysis import AnalysisLevel\n        &gt;&gt;&gt; ja = JavaAnalysis(project_dir='path/to/project', source_code=None,\n        ...                  analysis_backend_path=None, analysis_json_path=None,\n        ...                  analysis_level=AnalysisLevel.symbol_table,\n        ...                  target_files=None, eager_analysis=False)\n        &gt;&gt;&gt; classes = ja.get_classes()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(classes, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_classes()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_classes_by_criteria","title":"<code>get_classes_by_criteria(inclusions=None, exclusions=None)</code>","text":"<p>Return classes filtered by simple inclusion/exclusion criteria.</p> <p>Parameters:</p> Name Type Description Default <code>inclusions</code> <code>list[str] | None</code> <p>If provided, only classes whose name contains any of these substrings are included.</p> <code>None</code> <code>exclusions</code> <code>list[str] | None</code> <p>If provided, classes whose name contains any of these substrings are excluded.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>dict[str, JType]: Matching classes keyed by qualified class name.</p> <p>Examples:</p> <p>Filter classes using simple contains checks (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; filtered = ja.get_classes_by_criteria(inclusions=['Service'], exclusions=['Test'])\n&gt;&gt;&gt; isinstance(filtered, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_classes_by_criteria(self, inclusions=None, exclusions=None) -&gt; Dict[str, JType]:\n    \"\"\"Return classes filtered by simple inclusion/exclusion criteria.\n\n    Args:\n        inclusions (list[str] | None): If provided, only classes whose name\n            contains any of these substrings are included.\n        exclusions (list[str] | None): If provided, classes whose name contains\n            any of these substrings are excluded.\n\n    Returns:\n        dict[str, JType]: Matching classes keyed by qualified class name.\n\n    Examples:\n        Filter classes using simple contains checks (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; filtered = ja.get_classes_by_criteria(inclusions=['Service'], exclusions=['Test'])  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(filtered, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    if exclusions is None:\n        exclusions = []\n    if inclusions is None:\n        inclusions = []\n    class_dict: Dict[str, JType] = {}\n    all_classes = self.backend.get_all_classes()\n    for application_class in all_classes:\n        is_selected = False\n        for inclusion in inclusions:\n            if inclusion in application_class:\n                is_selected = True\n\n        for exclusion in exclusions:\n            if exclusion in application_class:\n                is_selected = False\n        if is_selected:\n            class_dict[application_class] = all_classes[application_class]\n    return class_dict\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_class","title":"<code>get_class(qualified_class_name)</code>","text":"<p>Return a class object.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Name Type Description <code>JType</code> <code>JType</code> <p>Class object for the given class.</p> <p>Examples:</p> <p>Look up a class by its qualified name (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; c = ja.get_class('com.example.A')\n&gt;&gt;&gt; c is not None\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class(self, qualified_class_name: str) -&gt; JType:\n    \"\"\"Return a class object.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        JType: Class object for the given class.\n\n    Examples:\n        Look up a class by its qualified name (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; c = ja.get_class('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; c is not None  # doctest: +SKIP\n        True\n    \"\"\"\n\n    return self.backend.get_class(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_method","title":"<code>get_method(qualified_class_name, qualified_method_name)</code>","text":"<p>Return a method object.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <code>qualified_method_name</code> <code>str</code> <p>Qualified method name.</p> required <p>Returns:</p> Name Type Description <code>JCallable</code> <code>JCallable</code> <p>Method object.</p> <p>Examples:</p> <p>Look up a method by its qualified signature (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; m = ja.get_method('com.example.A', 'f()')\n&gt;&gt;&gt; m is not None\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_method(self, qualified_class_name: str, qualified_method_name: str) -&gt; JCallable:\n    \"\"\"Return a method object.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n        qualified_method_name (str): Qualified method name.\n\n    Returns:\n        JCallable: Method object.\n\n    Examples:\n        Look up a method by its qualified signature (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; m = ja.get_method('com.example.A', 'f()')  # doctest: +SKIP\n        &gt;&gt;&gt; m is not None  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_method(qualified_class_name, qualified_method_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_method_parameters","title":"<code>get_method_parameters(qualified_class_name, qualified_method_name)</code>","text":"<p>Return the parameter types/names for a method.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <code>qualified_method_name</code> <code>str</code> <p>Qualified method name.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Method parameters.</p> <p>Examples:</p> <p>List parameters for a method (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; params = ja.get_method_parameters('com.example.A', 'g(int, java.lang.String)')\n&gt;&gt;&gt; isinstance(params, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_method_parameters(self, qualified_class_name: str, qualified_method_name: str) -&gt; List[str]:\n    \"\"\"Return the parameter types/names for a method.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n        qualified_method_name (str): Qualified method name.\n\n    Returns:\n        list[str]: Method parameters.\n\n    Examples:\n        List parameters for a method (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; params = ja.get_method_parameters('com.example.A', 'g(int, java.lang.String)')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(params, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_method_parameters(qualified_class_name, qualified_method_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_java_file","title":"<code>get_java_file(qualified_class_name)</code>","text":"<p>Return the Java file path containing a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the Java file.</p> <p>Examples:</p> <p>Get the source file path for a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; path = ja.get_java_file('com.example.A')\n&gt;&gt;&gt; isinstance(path, str)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_java_file(self, qualified_class_name: str) -&gt; str:\n    \"\"\"Return the Java file path containing a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        str: Path to the Java file.\n\n    Examples:\n        Get the source file path for a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; path = ja.get_java_file('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(path, str)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_java_file(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_java_compilation_unit","title":"<code>get_java_compilation_unit(file_path)</code>","text":"<p>Return the compilation unit for a Java source file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute path to a Java source file.</p> required <p>Returns:</p> Name Type Description <code>JCompilationUnit</code> <code>JCompilationUnit</code> <p>Compilation unit object.</p> <p>Examples:</p> <p>Parse a Java file into a compilation unit (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; cu = ja.get_java_compilation_unit('/abs/path/to/A.java')\n&gt;&gt;&gt; cu is not None\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_java_compilation_unit(self, file_path: str) -&gt; JCompilationUnit:\n    \"\"\"Return the compilation unit for a Java source file.\n\n    Args:\n        file_path (str): Absolute path to a Java source file.\n\n    Returns:\n        JCompilationUnit: Compilation unit object.\n\n    Examples:\n        Parse a Java file into a compilation unit (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; cu = ja.get_java_compilation_unit('/abs/path/to/A.java')  # doctest: +SKIP\n        &gt;&gt;&gt; cu is not None  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_java_compilation_unit(file_path)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_methods_in_class","title":"<code>get_methods_in_class(qualified_class_name)</code>","text":"<p>Return all methods of a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>Dict[str, JCallable]</code> <p>dict[str, JCallable]: Methods keyed by signature.</p> <p>Examples:</p> <p>List methods declared in a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; methods = ja.get_methods_in_class('com.example.A')\n&gt;&gt;&gt; isinstance(methods, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods_in_class(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n    \"\"\"Return all methods of a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        dict[str, JCallable]: Methods keyed by signature.\n\n    Examples:\n        List methods declared in a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; methods = ja.get_methods_in_class('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(methods, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_methods_in_class(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_constructors","title":"<code>get_constructors(qualified_class_name)</code>","text":"<p>Return all constructors of a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>Dict[str, JCallable]</code> <p>dict[str, JCallable]: Constructors keyed by signature.</p> <p>Examples:</p> <p>List constructors declared in a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; ctors = ja.get_constructors('com.example.A')\n&gt;&gt;&gt; isinstance(ctors, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_constructors(self, qualified_class_name) -&gt; Dict[str, JCallable]:\n    \"\"\"Return all constructors of a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        dict[str, JCallable]: Constructors keyed by signature.\n\n    Examples:\n        List constructors declared in a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; ctors = ja.get_constructors('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(ctors, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_constructors(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_fields","title":"<code>get_fields(qualified_class_name)</code>","text":"<p>Return all fields of a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>List[JField]</code> <p>list[JField]: All fields of the class.</p> <p>Examples:</p> <p>List fields declared in a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; fields = ja.get_fields('com.example.A')\n&gt;&gt;&gt; isinstance(fields, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_fields(self, qualified_class_name) -&gt; List[JField]:\n    \"\"\"Return all fields of a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        list[JField]: All fields of the class.\n\n    Examples:\n        List fields declared in a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; fields = ja.get_fields('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(fields, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_fields(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_nested_classes","title":"<code>get_nested_classes(qualified_class_name)</code>","text":"<p>Return all nested classes of a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>List[JType]</code> <p>list[JType]: Nested classes.</p> <p>Examples:</p> <p>List nested classes declared in a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; nested = ja.get_nested_classes('com.example.A')\n&gt;&gt;&gt; isinstance(nested, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_nested_classes(self, qualified_class_name) -&gt; List[JType]:\n    \"\"\"Return all nested classes of a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        list[JType]: Nested classes.\n\n    Examples:\n        List nested classes declared in a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; nested = ja.get_nested_classes('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(nested, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_nested_classes(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_sub_classes","title":"<code>get_sub_classes(qualified_class_name)</code>","text":"<p>Return all subclasses of a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>dict[str, JType]: Subclasses keyed by qualified name.</p> <p>Examples:</p> <p>List subclasses of a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; subs = ja.get_sub_classes('com.example.A')\n&gt;&gt;&gt; isinstance(subs, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_sub_classes(self, qualified_class_name) -&gt; Dict[str, JType]:\n    \"\"\"Return all subclasses of a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        dict[str, JType]: Subclasses keyed by qualified name.\n\n    Examples:\n        List subclasses of a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; subs = ja.get_sub_classes('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(subs, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_sub_classes(qualified_class_name=qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_extended_classes","title":"<code>get_extended_classes(qualified_class_name)</code>","text":"<p>Return all extended superclasses for a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Extended classes.</p> <p>Examples:</p> <p>List extended classes for a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; supers = ja.get_extended_classes('com.example.A')\n&gt;&gt;&gt; isinstance(supers, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_extended_classes(self, qualified_class_name) -&gt; List[str]:\n    \"\"\"Return all extended superclasses for a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        list[str]: Extended classes.\n\n    Examples:\n        List extended classes for a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; supers = ja.get_extended_classes('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(supers, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_extended_classes(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_implemented_interfaces","title":"<code>get_implemented_interfaces(qualified_class_name)</code>","text":"<p>Return all implemented interfaces for a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Implemented interfaces.</p> <p>Examples:</p> <p>List implemented interfaces for a class (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; ifaces = ja.get_implemented_interfaces('com.example.A')\n&gt;&gt;&gt; isinstance(ifaces, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_implemented_interfaces(self, qualified_class_name: str) -&gt; List[str]:\n    \"\"\"Return all implemented interfaces for a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        list[str]: Implemented interfaces.\n\n    Examples:\n        List implemented interfaces for a class (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; ifaces = ja.get_implemented_interfaces('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(ifaces, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_implemented_interfaces(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_class_call_graph","title":"<code>get_class_call_graph(qualified_class_name, method_signature=None, using_symbol_table=False)</code>","text":"<p>Return a class-level call graph.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <code>method_signature</code> <code>str | None</code> <p>Optional method signature to scope the graph.</p> <code>None</code> <code>using_symbol_table</code> <code>bool</code> <p>If True, use the symbol table for resolution.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Tuple[JMethodDetail, JMethodDetail]]</code> <p>list[tuple[JMethodDetail, JMethodDetail]]: Edge list of caller -&gt; callee.</p> <p>Examples:</p> <p>Build a class-level call graph (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project', analysis_level='call-graph')\n&gt;&gt;&gt; edges = ja.get_class_call_graph('com.example.A')\n&gt;&gt;&gt; isinstance(edges, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_class_call_graph(self, qualified_class_name: str, method_signature: str | None = None, using_symbol_table: bool = False) -&gt; List[Tuple[JMethodDetail, JMethodDetail]]:\n    \"\"\"Return a class-level call graph.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n        method_signature (str | None): Optional method signature to scope the graph.\n        using_symbol_table (bool): If True, use the symbol table for resolution.\n\n    Returns:\n        list[tuple[JMethodDetail, JMethodDetail]]: Edge list of caller -&gt; callee.\n\n    Examples:\n        Build a class-level call graph (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project', analysis_level='call-graph')\n        &gt;&gt;&gt; edges = ja.get_class_call_graph('com.example.A')  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(edges, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    if using_symbol_table:\n        return self.__get_class_call_graph_using_symbol_table(qualified_class_name=qualified_class_name, method_signature=method_signature)\n    return self.backend.get_class_call_graph(qualified_class_name, method_signature)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_entry_point_classes","title":"<code>get_entry_point_classes()</code>","text":"<p>Return all entry-point classes.</p> <p>Returns:</p> Type Description <code>Dict[str, JType]</code> <p>dict[str, JType]: Entry-point classes keyed by qualified class name.</p> <p>Examples:</p> <p>List entry-point classes in an application (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; eps = ja.get_entry_point_classes()\n&gt;&gt;&gt; isinstance(eps, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_entry_point_classes(self) -&gt; Dict[str, JType]:\n    \"\"\"Return all entry-point classes.\n\n    Returns:\n        dict[str, JType]: Entry-point classes keyed by qualified class name.\n\n    Examples:\n        List entry-point classes in an application (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; eps = ja.get_entry_point_classes()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(eps, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_entry_point_classes()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_entry_point_methods","title":"<code>get_entry_point_methods()</code>","text":"<p>Return all entry-point methods grouped by class.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, JCallable]]</code> <p>dict[str, dict[str, JCallable]]: Entry-point methods keyed by class.</p> <p>Examples:</p> <p>List entry-point methods in an application (backend required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; epms = ja.get_entry_point_methods()\n&gt;&gt;&gt; isinstance(epms, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_entry_point_methods(self) -&gt; Dict[str, Dict[str, JCallable]]:\n    \"\"\"Return all entry-point methods grouped by class.\n\n    Returns:\n        dict[str, dict[str, JCallable]]: Entry-point methods keyed by class.\n\n    Examples:\n        List entry-point methods in an application (backend required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; epms = ja.get_entry_point_methods()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(epms, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_entry_point_methods()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.remove_all_comments","title":"<code>remove_all_comments()</code>","text":"<p>Remove all comments from the source code.</p> <pre><code>    Returns:\n        str: Source code with comments removed.\n\n    Examples:\n        Remove comments from inline source code:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; src = 'class A { /* c */ // d\n</code></pre> <p>void f(){} }'.replace(' ', ' ')             &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)             &gt;&gt;&gt; cleaned = ja.remove_all_comments()  # doctest: +SKIP             &gt;&gt;&gt; '/*' in cleaned or '//' in cleaned  # doctest: +SKIP             False</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def remove_all_comments(self) -&gt; str:\n    \"\"\"Remove all comments from the source code.\n\n    Returns:\n        str: Source code with comments removed.\n\n    Examples:\n        Remove comments from inline source code:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; src = 'class A { /* c */ // d\\n void f(){} }'.replace('\\n', ' ')\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n        &gt;&gt;&gt; cleaned = ja.remove_all_comments()  # doctest: +SKIP\n        &gt;&gt;&gt; '/*' in cleaned or '//' in cleaned  # doctest: +SKIP\n        False\n    \"\"\"\n    return self.backend.remove_all_comments(self.source_code)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_methods_with_annotations","title":"<code>get_methods_with_annotations(annotations)</code>","text":"<p>Return methods grouped by the given annotations.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>list[str]</code> <p>Annotations to search for.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>dict[str, list[dict]]: Methods and bodies keyed by annotation.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_methods_with_annotations(self, annotations: List[str]) -&gt; Dict[str, List[Dict]]:\n    \"\"\"Return methods grouped by the given annotations.\n\n    Args:\n        annotations (list[str]): Annotations to search for.\n\n    Returns:\n        dict[str, list[dict]]: Methods and bodies keyed by annotation.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n    \"\"\"\n    # TODO: This call is missing some implementation. The logic currently resides in java_sitter but tree_sitter will no longer be option, rather it will be default and common. Need to implement this differently. Somthing like, self.commons.treesitter.get_methods_with_annotations(annotations)\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_test_methods","title":"<code>get_test_methods()</code>","text":"<p>Return test methods discovered in the source code.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>dict[str, str]: Mapping of method signature to body.</p> <p>Examples:</p> <p>Extract test methods from inline source code:</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; src = 'import org.junit.Test; class A { @Test public void t(){} }'\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n&gt;&gt;&gt; tests = ja.get_test_methods()\n&gt;&gt;&gt; isinstance(tests, dict)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_test_methods(self) -&gt; Dict[str, str]:\n    \"\"\"Return test methods discovered in the source code.\n\n    Returns:\n        dict[str, str]: Mapping of method signature to body.\n\n    Examples:\n        Extract test methods from inline source code:\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; src = 'import org.junit.Test; class A { @Test public void t(){} }'\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(source_code=src)\n        &gt;&gt;&gt; tests = ja.get_test_methods()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(tests, dict)  # doctest: +SKIP\n        True\n    \"\"\"\n\n    return self.treesitter_java.get_test_methods(source_class_code=self.source_code)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_calling_lines","title":"<code>get_calling_lines(target_method_name)</code>","text":"<p>Return line numbers where a target method is called within a method body.</p> <p>Parameters:</p> Name Type Description Default <code>target_method_name</code> <code>str</code> <p>Target method name.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>list[int]: Line numbers within the source method code block.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_calling_lines(self, target_method_name: str) -&gt; List[int]:\n    \"\"\"Return line numbers where a target method is called within a method body.\n\n    Args:\n        target_method_name (str): Target method name.\n\n    Returns:\n        list[int]: Line numbers within the source method code block.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_call_targets","title":"<code>get_call_targets(declared_methods)</code>","text":"<p>Return call targets using simple name resolution over the AST.</p> <p>Parameters:</p> Name Type Description Default <code>declared_methods</code> <code>dict</code> <p>All methods declared in the class.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>set[str]: Discovered call targets.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_call_targets(self, declared_methods: dict) -&gt; Set[str]:\n    \"\"\"Return call targets using simple name resolution over the AST.\n\n    Args:\n        declared_methods (dict): All methods declared in the class.\n\n    Returns:\n        set[str]: Discovered call targets.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_crud_operations","title":"<code>get_all_crud_operations()</code>","text":"<p>Return all CRUD operations in the source code.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]</code> <p>list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: CRUD operations grouped by class/method.</p> <p>Examples:</p> <p>Get all CRUD operations discovered by the backend (project required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; ops = ja.get_all_crud_operations()\n&gt;&gt;&gt; isinstance(ops, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_crud_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n    \"\"\"Return all CRUD operations in the source code.\n\n    Returns:\n        list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: CRUD operations grouped by class/method.\n\n    Examples:\n        Get all CRUD operations discovered by the backend (project required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; ops = ja.get_all_crud_operations()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(ops, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_crud_operations()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_create_operations","title":"<code>get_all_create_operations()</code>","text":"<p>Return all create operations in the source code.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]</code> <p>list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Create operations.</p> <p>Examples:</p> <p>Get create operations (project required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; creates = ja.get_all_create_operations()\n&gt;&gt;&gt; isinstance(creates, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_create_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n    \"\"\"Return all create operations in the source code.\n\n    Returns:\n        list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Create operations.\n\n    Examples:\n        Get create operations (project required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; creates = ja.get_all_create_operations()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(creates, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_create_operations()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_read_operations","title":"<code>get_all_read_operations()</code>","text":"<p>Return all read operations in the source code.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]</code> <p>list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Read operations.</p> <p>Examples:</p> <p>Get read operations (project required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; reads = ja.get_all_read_operations()\n&gt;&gt;&gt; isinstance(reads, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_read_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n    \"\"\"Return all read operations in the source code.\n\n    Returns:\n        list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Read operations.\n\n    Examples:\n        Get read operations (project required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; reads = ja.get_all_read_operations()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(reads, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_read_operations()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_update_operations","title":"<code>get_all_update_operations()</code>","text":"<p>Return all update operations in the source code.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]</code> <p>list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Update operations.</p> <p>Examples:</p> <p>Get update operations (project required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; updates = ja.get_all_update_operations()\n&gt;&gt;&gt; isinstance(updates, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_update_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n    \"\"\"Return all update operations in the source code.\n\n    Returns:\n        list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Update operations.\n\n    Examples:\n        Get update operations (project required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; updates = ja.get_all_update_operations()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(updates, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_update_operations()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_delete_operations","title":"<code>get_all_delete_operations()</code>","text":"<p>Return all delete operations in the source code.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]</code> <p>list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Delete operations.</p> <p>Examples:</p> <p>Get delete operations (project required):</p> <pre><code>&gt;&gt;&gt; from cldk import CLDK\n&gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n&gt;&gt;&gt; deletes = ja.get_all_delete_operations()\n&gt;&gt;&gt; isinstance(deletes, list)\nTrue\n</code></pre> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_delete_operations(self) -&gt; List[Dict[str, Union[JType, JCallable, List[JCRUDOperation]]]]:\n    \"\"\"Return all delete operations in the source code.\n\n    Returns:\n        list[dict[str, Union[JType, JCallable, list[JCRUDOperation]]]]: Delete operations.\n\n    Examples:\n        Get delete operations (project required):\n\n        &gt;&gt;&gt; from cldk import CLDK\n        &gt;&gt;&gt; ja = CLDK(language=\"java\").analysis(project_path='path/to/project')\n        &gt;&gt;&gt; deletes = ja.get_all_delete_operations()  # doctest: +SKIP\n        &gt;&gt;&gt; isinstance(deletes, list)  # doctest: +SKIP\n        True\n    \"\"\"\n    return self.backend.get_all_delete_operations()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_comments_in_a_method","title":"<code>get_comments_in_a_method(qualified_class_name, method_signature)</code>","text":"<p>Return all comments in a method.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <code>method_signature</code> <code>str</code> <p>Method signature.</p> required <p>Returns:</p> Type Description <code>List[JComment]</code> <p>list[JComment]: Comments in the method.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_comments_in_a_method(self, qualified_class_name: str, method_signature: str) -&gt; List[JComment]:\n    \"\"\"Return all comments in a method.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n        method_signature (str): Method signature.\n\n    Returns:\n        list[JComment]: Comments in the method.\n    \"\"\"\n    return self.backend.get_comments_in_a_method(qualified_class_name, method_signature)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_comments_in_a_class","title":"<code>get_comments_in_a_class(qualified_class_name)</code>","text":"<p>Return all comments in a class.</p> <p>Parameters:</p> Name Type Description Default <code>qualified_class_name</code> <code>str</code> <p>Qualified class name.</p> required <p>Returns:</p> Type Description <code>List[JComment]</code> <p>list[JComment]: Comments in the class.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_comments_in_a_class(self, qualified_class_name: str) -&gt; List[JComment]:\n    \"\"\"Return all comments in a class.\n\n    Args:\n        qualified_class_name (str): Qualified class name.\n\n    Returns:\n        list[JComment]: Comments in the class.\n    \"\"\"\n    return self.backend.get_comments_in_a_class(qualified_class_name)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_comment_in_file","title":"<code>get_comment_in_file(file_path)</code>","text":"<p>Return all comments in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute file path.</p> required <p>Returns:</p> Type Description <code>List[JComment]</code> <p>list[JComment]: Comments in the file.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_comment_in_file(self, file_path: str) -&gt; List[JComment]:\n    \"\"\"Return all comments in a file.\n\n    Args:\n        file_path (str): Absolute file path.\n\n    Returns:\n        list[JComment]: Comments in the file.\n    \"\"\"\n    return self.backend.get_comment_in_file(file_path)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_comments","title":"<code>get_all_comments()</code>","text":"<p>Return all comments grouped by file.</p> <p>Returns:</p> Type Description <code>Dict[str, List[JComment]]</code> <p>dict[str, list[JComment]]: Mapping of file path to comments.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_comments(self) -&gt; Dict[str, List[JComment]]:\n    \"\"\"Return all comments grouped by file.\n\n    Returns:\n        dict[str, list[JComment]]: Mapping of file path to comments.\n    \"\"\"\n    return self.backend.get_all_comments()\n</code></pre>"},{"location":"reference/python-api/java/#cldk.analysis.java.java_analysis.JavaAnalysis.get_all_docstrings","title":"<code>get_all_docstrings()</code>","text":"<p>Return all docstrings grouped by file.</p> <p>Returns:</p> Type Description <code>Dict[str, List[JComment]]</code> <p>dict[str, list[JComment]]: Mapping of file path to docstrings.</p> Source code in <code>cldk/analysis/java/java_analysis.py</code> <pre><code>def get_all_docstrings(self) -&gt; Dict[str, List[JComment]]:\n    \"\"\"Return all docstrings grouped by file.\n\n    Returns:\n        dict[str, list[JComment]]: Mapping of file path to docstrings.\n    \"\"\"\n    return self.backend.get_all_docstrings()\n</code></pre>"},{"location":"reference/python-api/java/#schema","title":"Schema","text":"<p>Models module</p>"},{"location":"reference/python-api/java/#cldk.models.java.models.JComment","title":"<code>JComment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a comment in Java code.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The content of the comment.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the comment in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the comment in the source file.</p> <code>start_column</code> <code>int</code> <p>The starting column of the comment in the source file.</p> <code>end_column</code> <code>int</code> <p>The ending column of the comment in the source file.</p> <code>is_javadoc</code> <code>bool</code> <p>A flag indicating whether the comment is a Javadoc comment.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JComment(BaseModel):\n    \"\"\"Represents a comment in Java code.\n\n    Attributes:\n        content (str): The content of the comment.\n        start_line (int): The starting line number of the comment in the source file.\n        end_line (int): The ending line number of the comment in the source file.\n        start_column (int): The starting column of the comment in the source file.\n        end_column (int): The ending column of the comment in the source file.\n        is_javadoc (bool): A flag indicating whether the comment is a Javadoc comment.\n    \"\"\"\n\n    content: str | None = None\n    start_line: int = -1\n    end_line: int = -1\n    start_column: int = -1\n    end_column: int = -1\n    is_javadoc: bool = False\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JRecordComponent","title":"<code>JRecordComponent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a component of a Java record.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>JComment</code> <p>The comment associated with the component.</p> <code>name</code> <code>str</code> <p>The name of the component.</p> <code>type</code> <code>str</code> <p>The type of the component.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the component.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the component.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JRecordComponent(BaseModel):\n    \"\"\"Represents a component of a Java record.\n\n    Attributes:\n        comment (JComment): The comment associated with the component.\n        name (str): The name of the component.\n        type (str): The type of the component.\n        annotations (List[str]): The annotations applied to the component.\n        modifiers (List[str]): The modifiers applied to the component.\n    \"\"\"\n\n    comment: JComment | None\n    name: str\n    type: str\n    modifiers: List[str]\n    annotations: List[str]\n    default_value: Union[str, None, Any] = None\n    is_var_args: bool = False\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JField","title":"<code>JField</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a field in a Java class or interface.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>JComment</code> <p>The comment associated with the field.</p> <code>name</code> <code>str</code> <p>The name of the field.</p> <code>type</code> <code>str</code> <p>The type of the field.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the field in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the field in the source file.</p> <code>variables</code> <code>List[str]</code> <p>The variables declared in the field.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the field (e.g., public, static).</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the field.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JField(BaseModel):\n    \"\"\"Represents a field in a Java class or interface.\n\n    Attributes:\n        comment (JComment): The comment associated with the field.\n        name (str): The name of the field.\n        type (str): The type of the field.\n        start_line (int): The starting line number of the field in the source file.\n        end_line (int): The ending line number of the field in the source file.\n        variables (List[str]): The variables declared in the field.\n        modifiers (List[str]): The modifiers applied to the field (e.g., public, static).\n        annotations (List[str]): The annotations applied to the field.\n    \"\"\"\n\n    comment: JComment | None\n    type: str\n    start_line: int\n    end_line: int\n    variables: List[str]\n    modifiers: List[str]\n    annotations: List[str]\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCallableParameter","title":"<code>JCallableParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a parameter of a Java callable.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the parameter.</p> <code>type</code> <code>str</code> <p>The type of the parameter.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the parameter.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the parameter.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the parameter in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the parameter in the source file.</p> <code>start_column</code> <code>int</code> <p>The starting column of the parameter in the source file.</p> <code>end_column</code> <code>int</code> <p>The ending column of the parameter in the source file.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallableParameter(BaseModel):\n    \"\"\"Represents a parameter of a Java callable.\n\n    Attributes:\n        name (str): The name of the parameter.\n        type (str): The type of the parameter.\n        annotations (List[str]): The annotations applied to the parameter.\n        modifiers (List[str]): The modifiers applied to the parameter.\n        start_line (int): The starting line number of the parameter in the source file.\n        end_line (int): The ending line number of the parameter in the source file.\n        start_column (int): The starting column of the parameter in the source file.\n        end_column (int): The ending column of the parameter in the source file.\n    \"\"\"\n\n    name: str | None\n    type: str\n    annotations: List[str]\n    modifiers: List[str]\n    start_line: int\n    end_line: int\n    start_column: int\n    end_column: int\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JEnumConstant","title":"<code>JEnumConstant</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a constant in an enumeration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the enum constant.</p> <code>arguments</code> <code>List[str]</code> <p>The arguments associated with the enum constant.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JEnumConstant(BaseModel):\n    \"\"\"Represents a constant in an enumeration.\n\n    Attributes:\n        name (str): The name of the enum constant.\n        arguments (List[str]): The arguments associated with the enum constant.\n    \"\"\"\n\n    name: str\n    arguments: List[str]\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCRUDOperation","title":"<code>JCRUDOperation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a CRUD operation.</p> <p>Attributes:</p> Name Type Description <code>line_number</code> <code>int</code> <p>The line number of the operation.</p> <code>operation_type</code> <code>JCRUDOperationType</code> <p>The type of the operation.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCRUDOperation(BaseModel):\n    \"\"\"Represents a CRUD operation.\n\n    Attributes:\n        line_number (int): The line number of the operation.\n        operation_type (JCRUDOperationType): The type of the operation.\n    \"\"\"\n\n    line_number: int\n    operation_type: CRUDOperationType | None\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCRUDQuery","title":"<code>JCRUDQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a CRUD query.</p> <p>Attributes:</p> Name Type Description <code>line_number</code> <code>int</code> <p>The line number of the query.</p> <code>query_arguments</code> <code>List[str]</code> <p>The arguments of the query.</p> <code>query_type</code> <code>JCRUDQueryType</code> <p>The type of the query.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCRUDQuery(BaseModel):\n    \"\"\"Represents a CRUD query.\n\n    Attributes:\n        line_number (int): The line number of the query.\n        query_arguments (List[str]): The arguments of the query.\n        query_type (JCRUDQueryType): The type of the query.\n    \"\"\"\n\n    line_number: int\n    query_arguments: List[str] | None\n    query_type: CRUDQueryType | None\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCallSite","title":"<code>JCallSite</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a call site.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>JComment</code> <p>The comment associated with the call site.</p> <code>method_name</code> <code>str</code> <p>The name of the method called at the call site.</p> <code>receiver_expr</code> <code>str</code> <p>Expression for the receiver of the method call.</p> <code>receiver_type</code> <code>str</code> <p>Name of type declaring the called method.</p> <code>argument_types</code> <code>List[str]</code> <p>Types of actual parameters for the call.</p> <code>argument_expr</code> <code>List[str]</code> <p>Actual parameter expressions for the call.</p> <code>return_type</code> <code>str</code> <p>Return type of the method call (resolved type of the method call expression; empty string if expression is unresolved).</p> <code>callee_signature</code> <code>str</code> <p>Signature of the callee.</p> <code>is_static_call</code> <code>bool</code> <p>Flag indicating whether the call is a static call.</p> <code>is_private</code> <code>bool</code> <p>Flag indicating whether the call is a private call.</p> <code>is_public</code> <code>bool</code> <p>Flag indicating whether the call is a public call.</p> <code>is_protected</code> <code>bool</code> <p>Flag indicating whether the call is a protected call.</p> <code>is_unspecified</code> <code>bool</code> <p>Flag indicating whether the call is an unspecified call.</p> <code>is_constructor_call</code> <code>bool</code> <p>Flag indicating whether the call is a constructor call.</p> <code>crud_operation</code> <code>CRUDOperationType</code> <p>The CRUD operation type of the call site.</p> <code>crud_query</code> <code>CRUDQueryType</code> <p>The CRUD query type of the call site.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the call site.</p> <code>start_column</code> <code>int</code> <p>The starting column of the call site.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the call site.</p> <code>end_column</code> <code>int</code> <p>The ending column of the call site.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallSite(BaseModel):\n    \"\"\"Represents a call site.\n\n    Attributes:\n        comment (JComment): The comment associated with the call site.\n        method_name (str): The name of the method called at the call site.\n        receiver_expr (str): Expression for the receiver of the method call.\n        receiver_type (str): Name of type declaring the called method.\n        argument_types (List[str]): Types of actual parameters for the call.\n        argument_expr (List[str]): Actual parameter expressions for the call.\n        return_type (str): Return type of the method call (resolved type of the method call expression; empty string if expression is unresolved).\n        callee_signature (str): Signature of the callee.\n        is_static_call (bool): Flag indicating whether the call is a static call.\n        is_private (bool): Flag indicating whether the call is a private call.\n        is_public (bool): Flag indicating whether the call is a public call.\n        is_protected (bool): Flag indicating whether the call is a protected call.\n        is_unspecified (bool): Flag indicating whether the call is an unspecified call.\n        is_constructor_call (bool): Flag indicating whether the call is a constructor call.\n        crud_operation (CRUDOperationType): The CRUD operation type of the call site.\n        crud_query (CRUDQueryType): The CRUD query type of the call site.\n        start_line (int): The starting line number of the call site.\n        start_column (int): The starting column of the call site.\n        end_line (int): The ending line number of the call site.\n        end_column (int): The ending column of the call site.\n    \"\"\"\n\n    comment: JComment | None\n    method_name: str\n    receiver_expr: str = \"\"\n    receiver_type: str\n    argument_types: List[str]\n    argument_expr: List[str]\n    return_type: str = \"\"\n    callee_signature: str = \"\"\n    is_static_call: bool | None = None\n    is_private: bool | None = None\n    is_public: bool | None = None\n    is_protected: bool | None = None\n    is_unspecified: bool | None = None\n    is_constructor_call: bool\n    crud_operation: JCRUDOperation | None\n    crud_query: JCRUDQuery | None\n    start_line: int\n    start_column: int\n    end_line: int\n    end_column: int\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JVariableDeclaration","title":"<code>JVariableDeclaration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a variable declaration.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>JComment</code> <p>The comment associated with the variable declaration.</p> <code>name</code> <code>str</code> <p>The name of the variable.</p> <code>type</code> <code>str</code> <p>The type of the variable.</p> <code>initializer</code> <code>str</code> <p>The initialization expression (if present) for the variable declaration.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the declaration.</p> <code>start_column</code> <code>int</code> <p>The starting column of the declaration.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the declaration.</p> <code>end_column</code> <code>int</code> <p>The ending column of the declaration.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JVariableDeclaration(BaseModel):\n    \"\"\"Represents a variable declaration.\n\n    Attributes:\n        comment (JComment): The comment associated with the variable declaration.\n        name (str): The name of the variable.\n        type (str): The type of the variable.\n        initializer (str): The initialization expression (if present) for the variable declaration.\n        start_line (int): The starting line number of the declaration.\n        start_column (int): The starting column of the declaration.\n        end_line (int): The ending line number of the declaration.\n        end_column (int): The ending column of the declaration.\n    \"\"\"\n\n    comment: JComment | None\n    name: str\n    type: str\n    initializer: str\n    start_line: int\n    start_column: int\n    end_line: int\n    end_column: int\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.InitializationBlock","title":"<code>InitializationBlock</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an initialization block in Java.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The path to the source file.</p> <code>comments</code> <code>List[JComment]</code> <p>The comments associated with the block.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the block.</p> <code>thrown_exceptions</code> <code>List[str]</code> <p>Exceptions declared via \"throws\".</p> <code>code</code> <code>str</code> <p>The code block.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the block in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the block in the source file.</p> <code>is_static</code> <code>bool</code> <p>A flag indicating whether the block is static.</p> <code>referenced_types</code> <code>List[str]</code> <p>The types referenced within the block.</p> <code>accessed_fields</code> <code>List[str]</code> <p>Fields accessed in the block.</p> <code>call_sites</code> <code>List[JCallSite]</code> <p>Call sites in the block.</p> <code>variable_declarations</code> <code>List[JVariableDeclaration]</code> <p>Local variable declarations in the block.</p> <code>cyclomatic_complexity</code> <code>int</code> <p>Cyclomatic complexity of the block.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class InitializationBlock(BaseModel):\n    \"\"\"Represents an initialization block in Java.\n\n    Attributes:\n        file_path (str): The path to the source file.\n        comments (List[JComment]): The comments associated with the block.\n        annotations (List[str]): The annotations applied to the block.\n        thrown_exceptions (List[str]): Exceptions declared via \"throws\".\n        code (str): The code block.\n        start_line (int): The starting line number of the block in the source file.\n        end_line (int): The ending line number of the block in the source file.\n        is_static (bool): A flag indicating whether the block is static.\n        referenced_types (List[str]): The types referenced within the block.\n        accessed_fields (List[str]): Fields accessed in the block.\n        call_sites (List[JCallSite]): Call sites in the block.\n        variable_declarations (List[JVariableDeclaration]): Local variable declarations in the block.\n        cyclomatic_complexity (int): Cyclomatic complexity of the block.\n    \"\"\"\n\n    file_path: str\n    comments: List[JComment]\n    annotations: List[str]\n    thrown_exceptions: List[str]\n    code: str\n    start_line: int\n    end_line: int\n    is_static: bool\n    referenced_types: List[str]\n    accessed_fields: List[str]\n    call_sites: List[JCallSite]\n    variable_declarations: List[JVariableDeclaration]\n    cyclomatic_complexity: int\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCallable","title":"<code>JCallable</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a callable entity such as a method or constructor in Java.</p> <p>Attributes:</p> Name Type Description <code>signature</code> <code>str</code> <p>The signature of the callable.</p> <code>is_implicit</code> <code>bool</code> <p>A flag indicating whether the callable is implicit (e.g., a default constructor).</p> <code>is_constructor</code> <code>bool</code> <p>A flag indicating whether the callable is a constructor.</p> <code>comment</code> <code>List[JComment]</code> <p>A list of comments associated with the callable.</p> <code>annotations</code> <code>List[str]</code> <p>The annotations applied to the callable.</p> <code>modifiers</code> <code>List[str]</code> <p>The modifiers applied to the callable (e.g., public, static).</p> <code>thrown_exceptions</code> <code>List[str]</code> <p>Exceptions declared via \"throws\".</p> <code>declaration</code> <code>str</code> <p>The declaration of the callable.</p> <code>parameters</code> <code>List[JCallableParameter]</code> <p>The parameters of the callable.</p> <code>return_type</code> <code>Optional[str]</code> <p>The return type of the callable. None if the callable does not return a value (e.g., a constructor).</p> <code>code</code> <code>str</code> <p>The code block of the callable.</p> <code>start_line</code> <code>int</code> <p>The starting line number of the callable in the source file.</p> <code>end_line</code> <code>int</code> <p>The ending line number of the callable in the source file.</p> <code>code_start_line</code> <code>int</code> <p>The starting line number of the code block of a callable in the source file.</p> <code>referenced_types</code> <code>List[str]</code> <p>The types referenced within the callable.</p> <code>accessed_fields</code> <code>List[str]</code> <p>Fields accessed in the callable.</p> <code>call_sites</code> <code>List[JCallSite]</code> <p>Call sites in the callable.</p> <code>is_entrypoint</code> <code>bool</code> <p>A flag indicating whether this is a service entry point method.</p> <code>variable_declarations</code> <code>List[JVariableDeclaration]</code> <p>Local variable declarations in the callable.</p> <code>crud_operations</code> <code>List[JCRUDOperation]</code> <p>CRUD operations in the callable.</p> <code>crud_queries</code> <code>List[JCRUDQuery]</code> <p>CRUD queries in the callable.</p> <code>cyclomatic_complexity</code> <code>int</code> <p>Cyclomatic complexity of the callable.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCallable(BaseModel):\n    \"\"\"Represents a callable entity such as a method or constructor in Java.\n\n    Attributes:\n        signature (str): The signature of the callable.\n        is_implicit (bool): A flag indicating whether the callable is implicit (e.g., a default constructor).\n        is_constructor (bool): A flag indicating whether the callable is a constructor.\n        comment (List[JComment]): A list of comments associated with the callable.\n        annotations (List[str]): The annotations applied to the callable.\n        modifiers (List[str]): The modifiers applied to the callable (e.g., public, static).\n        thrown_exceptions (List[str]): Exceptions declared via \"throws\".\n        declaration (str): The declaration of the callable.\n        parameters (List[JCallableParameter]): The parameters of the callable.\n        return_type (Optional[str]): The return type of the callable. None if the callable does not return a value (e.g., a constructor).\n        code (str): The code block of the callable.\n        start_line (int): The starting line number of the callable in the source file.\n        end_line (int): The ending line number of the callable in the source file.\n        code_start_line (int): The starting line number of the code block of a callable in the source file.\n        referenced_types (List[str]): The types referenced within the callable.\n        accessed_fields (List[str]): Fields accessed in the callable.\n        call_sites (List[JCallSite]): Call sites in the callable.\n        is_entrypoint (bool): A flag indicating whether this is a service entry point method.\n        variable_declarations (List[JVariableDeclaration]): Local variable declarations in the callable.\n        crud_operations (List[JCRUDOperation]): CRUD operations in the callable.\n        crud_queries (List[JCRUDQuery]): CRUD queries in the callable.\n        cyclomatic_complexity (int): Cyclomatic complexity of the callable.\n    \"\"\"\n\n    signature: str\n    is_implicit: bool\n    is_constructor: bool\n    comments: List[JComment]\n    annotations: List[str]\n    modifiers: List[str]\n    thrown_exceptions: List[str] = []\n    declaration: str\n    parameters: List[JCallableParameter]\n    return_type: Optional[str] = None  # Pythonic way to denote a nullable field\n    code: str\n    start_line: int\n    end_line: int\n    code_start_line: int\n    referenced_types: List[str]\n    accessed_fields: List[str]\n    call_sites: List[JCallSite]\n    is_entrypoint: bool = False\n    variable_declarations: List[JVariableDeclaration]\n    crud_operations: List[JCRUDOperation] | None\n    crud_queries: List[JCRUDQuery] | None\n    cyclomatic_complexity: int | None\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash value of the declaration.\n        \"\"\"\n        return hash(self.declaration)\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JType","title":"<code>JType</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Java class or interface.</p> <p>Attributes:</p> Name Type Description <code>is_interface</code> <code>bool</code> <p>A flag indicating whether the object is an interface.</p> <code>is_inner_class</code> <code>bool</code> <p>A flag indicating whether the object is an inner class.</p> <code>is_local_class</code> <code>bool</code> <p>A flag indicating whether the object is a local class.</p> <code>is_nested_type</code> <code>bool</code> <p>A flag indicating whether the object is a nested type.</p> <code>is_class_or_interface_declaration</code> <code>bool</code> <p>A flag indicating whether the object is a class or interface declaration.</p> <code>is_enum_declaration</code> <code>bool</code> <p>A flag indicating whether the object is an enum declaration.</p> <code>is_annotation_declaration</code> <code>bool</code> <p>A flag indicating whether the object is an annotation declaration.</p> <code>is_record_declaration</code> <code>bool</code> <p>A flag indicating whether this object is a record declaration.</p> <code>is_concrete_class</code> <code>bool</code> <p>A flag indicating whether this is a concrete class.</p> <code>comments</code> <code>List[JComment]</code> <p>A list of comments associated with the class/type.</p> <code>extends_list</code> <code>List[str]</code> <p>The list of classes or interfaces that the object extends.</p> <code>implements_list</code> <code>List[str]</code> <p>The list of interfaces that the object implements.</p> <code>modifiers</code> <code>List[str]</code> <p>The list of modifiers of the object.</p> <code>annotations</code> <code>List[str]</code> <p>The list of annotations of the object.</p> <code>parent_type</code> <code>str</code> <p>The name of the parent class (if it exists).</p> <code>is_entrypoint_class</code> <code>bool</code> <p>A flag indicating whether this is a service entry point class.</p> <code>nested_type_declarations</code> <code>List[str]</code> <p>All the class declarations nested under this class.</p> <code>callable_declarations</code> <code>Dict[str, JCallable]</code> <p>The list of constructors and methods of the object.</p> <code>field_declarations</code> <code>List[JField]</code> <p>The list of fields of the object.</p> <code>enum_constants</code> <code>List[JEnumConstant]</code> <p>The list of enum constants in the object.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JType(BaseModel):\n    \"\"\"Represents a Java class or interface.\n\n    Attributes:\n        is_interface (bool): A flag indicating whether the object is an interface.\n        is_inner_class (bool): A flag indicating whether the object is an inner class.\n        is_local_class (bool): A flag indicating whether the object is a local class.\n        is_nested_type (bool): A flag indicating whether the object is a nested type.\n        is_class_or_interface_declaration (bool): A flag indicating whether the object is a class or interface declaration.\n        is_enum_declaration (bool): A flag indicating whether the object is an enum declaration.\n        is_annotation_declaration (bool): A flag indicating whether the object is an annotation declaration.\n        is_record_declaration (bool): A flag indicating whether this object is a record declaration.\n        is_concrete_class (bool): A flag indicating whether this is a concrete class.\n        comments (List[JComment]): A list of comments associated with the class/type.\n        extends_list (List[str]): The list of classes or interfaces that the object extends.\n        implements_list (List[str]): The list of interfaces that the object implements.\n        modifiers (List[str]): The list of modifiers of the object.\n        annotations (List[str]): The list of annotations of the object.\n        parent_type (str): The name of the parent class (if it exists).\n        is_entrypoint_class (bool): A flag indicating whether this is a service entry point class.\n        nested_type_declarations (List[str]): All the class declarations nested under this class.\n        callable_declarations (Dict[str, JCallable]): The list of constructors and methods of the object.\n        field_declarations (List[JField]): The list of fields of the object.\n        enum_constants (List[JEnumConstant]): The list of enum constants in the object.\n    \"\"\"\n\n    is_interface: bool = False\n    is_inner_class: bool = False\n    is_local_class: bool = False\n    is_nested_type: bool = False\n    is_class_or_interface_declaration: bool = False\n    is_enum_declaration: bool = False\n    is_annotation_declaration: bool = False\n    is_record_declaration: bool = False\n    is_concrete_class: bool = False\n    comments: List[JComment] | None = []\n    extends_list: List[str] | None = []\n    implements_list: List[str] | None = []\n    modifiers: List[str] | None = []\n    annotations: List[str] | None = []\n    parent_type: str\n    nested_type_declarations: List[str] | None = []\n    callable_declarations: Dict[str, JCallable] = {}\n    field_declarations: List[JField] = []\n    enum_constants: List[JEnumConstant] | None = []\n    record_components: List[JRecordComponent] | None = []\n    initialization_blocks: List[InitializationBlock] | None = []\n    is_entrypoint_class: bool = False\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JCompilationUnit","title":"<code>JCompilationUnit</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a compilation unit in Java.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The path to the source file.</p> <code>package_name</code> <code>str</code> <p>The name of the package for the comppilation unit.</p> <code>comments</code> <code>List[JComment]</code> <p>A list of comments in the compilation unit.</p> <code>imports</code> <code>List[str]</code> <p>A list of import statements in the compilation unit.</p> <code>type_declarations</code> <code>Dict[str, JType]</code> <p>A dictionary mapping type names to their corresponding JType representations.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JCompilationUnit(BaseModel):\n    \"\"\"Represents a compilation unit in Java.\n\n    Attributes:\n        file_path (str): The path to the source file.\n        package_name (str): The name of the package for the comppilation unit.\n        comments (List[JComment]): A list of comments in the compilation unit.\n        imports (List[str]): A list of import statements in the compilation unit.\n        type_declarations (Dict[str, JType]): A dictionary mapping type names to their corresponding JType representations.\n    \"\"\"\n\n    file_path: str\n    package_name: str\n    comments: List[JComment]\n    imports: List[str]\n    type_declarations: Dict[str, JType]\n    is_modified: bool = False\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JMethodDetail","title":"<code>JMethodDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents details about a method in a Java class.</p> <p>Attributes:</p> Name Type Description <code>method_declaration</code> <code>str</code> <p>The declaration string of the method.</p> <code>klass</code> <code>str</code> <p>The name of the class containing the method. 'class' is a reserved keyword in Python.</p> <code>method</code> <code>JCallable</code> <p>An instance of JCallable representing the callable details of the method.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JMethodDetail(BaseModel):\n    \"\"\"Represents details about a method in a Java class.\n\n    Attributes:\n        method_declaration (str): The declaration string of the method.\n        klass (str): The name of the class containing the method. 'class' is a reserved keyword in Python.\n        method (JCallable): An instance of JCallable representing the callable details of the method.\n    \"\"\"\n\n    method_declaration: str\n    # class is a reserved keyword in python. we'll use klass.\n    klass: str\n    method: JCallable\n\n    def __repr__(self):\n        return f\"JMethodDetail({self.method_declaration})\"\n\n    def __hash__(self):\n        return hash(tuple(self))\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JGraphEdgesST","title":"<code>JGraphEdgesST</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an edge in a graph structure for method dependencies.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>JMethodDetail</code> <p>The source method of the edge.</p> <code>target</code> <code>JMethodDetail</code> <p>The target method of the edge.</p> <code>type</code> <code>str</code> <p>The type of the edge.</p> <code>weight</code> <code>str</code> <p>The weight of the edge, indicating the strength or significance of the connection.</p> <code>source_kind</code> <code>Optional[str]</code> <p>The kind of the source method. Default is None.</p> <code>destination_kind</code> <code>Optional[str]</code> <p>The kind of the target method. Default is None.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JGraphEdgesST(BaseModel):\n    \"\"\"Represents an edge in a graph structure for method dependencies.\n\n    Attributes:\n        source (JMethodDetail): The source method of the edge.\n        target (JMethodDetail): The target method of the edge.\n        type (str): The type of the edge.\n        weight (str): The weight of the edge, indicating the strength or significance of the connection.\n        source_kind (Optional[str]): The kind of the source method. Default is None.\n        destination_kind (Optional[str]): The kind of the target method. Default is None.\n    \"\"\"\n\n    source: JMethodDetail\n    target: JMethodDetail\n    type: str\n    weight: str\n    source_kind: str | None = None\n    destination_kind: str | None = None\n</code></pre>"},{"location":"reference/python-api/java/#cldk.models.java.models.JApplication","title":"<code>JApplication</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Java application.</p>"},{"location":"reference/python-api/java/#cldk.models.java.models.JApplication--parameters","title":"Parameters","text":"<p>symbol_table : List[JCompilationUnit]     The symbol table representation system_dependency : List[JGraphEdges]     The edges of the system dependency graph. Default None.</p> Source code in <code>cldk/models/java/models.py</code> <pre><code>class JApplication(BaseModel):\n    \"\"\"\n    Represents a Java application.\n\n    Parameters\n    ----------\n    symbol_table : List[JCompilationUnit]\n        The symbol table representation\n    system_dependency : List[JGraphEdges]\n        The edges of the system dependency graph. Default None.\n    \"\"\"\n\n    symbol_table: Dict[str, JCompilationUnit]\n    call_graph: List[JGraphEdges] = None\n    system_dependency_graph: List[JGraphEdges] = None\n\n    @field_validator(\"symbol_table\", mode=\"after\")\n    @classmethod\n    def validate_source(cls, symbol_table) -&gt; Dict[str, JCompilationUnit]:\n        # Populate the lookup table for callables\n        for _, j_compulation_unit in symbol_table.items():\n            for type_declaration, jtype in j_compulation_unit.type_declarations.items():\n                for __, j_callable in jtype.callable_declarations.items():\n                    _CALLABLES_LOOKUP_TABLE[(type_declaration, j_callable.signature)] = j_callable\n\n        return symbol_table\n</code></pre>"},{"location":"reference/python-api/python/","title":"Python API","text":"<p>This page documents the Python-related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the Python analysis and schema packages.</p>"},{"location":"reference/python-api/python/#analysis","title":"Analysis","text":"<p>Python analysis utilities and workflows.</p> <p>Python analysis utilities.</p> <p>Provides a high-level API to query modules, classes, functions, and methods from Python projects or single-source inputs using Treesitter.</p>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis","title":"<code>PythonAnalysis</code>","text":"<p>Analysis fa\u00e7ade for Python code.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>str | Path | None</code> <p>Directory path of the project.</p> required <code>source_code</code> <code>str | None</code> <p>Source text for single-file analysis.</p> required Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>class PythonAnalysis:\n    \"\"\"Analysis fa\u00e7ade for Python code.\n\n    Args:\n        project_dir (str | Path | None): Directory path of the project.\n        source_code (str | None): Source text for single-file analysis.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_dir: str | Path | None,\n        source_code: str | None,\n    ) -&gt; None:\n        self.project_dir = project_dir\n        self.source_code = source_code\n        self.analysis_backend: TreesitterPython = TreesitterPython()\n\n    def get_methods(self) -&gt; List[PyMethod]:\n        \"\"\"Return all methods.\n\n        Returns:\n            list[PyMethod]: Methods discovered in the source code.\n\n        Examples:\n            &gt;&gt;&gt; src = 'class C: def f(self): pass def g(self): pass'\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)  # doctest: +SKIP\n            &gt;&gt;&gt; len(pa.get_methods())  # doctest: +SKIP\n            2\n        \"\"\"\n        return self.analysis_backend.get_all_methods(self.source_code)\n\n    def get_functions(self) -&gt; List[PyMethod]:\n        \"\"\"Return all functions.\n\n        Returns:\n            list[PyMethod]: Functions discovered in the source code.\n\n        Examples:\n            &gt;&gt;&gt; src = 'def f(): return 1'\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n            &gt;&gt;&gt; [m.full_signature for m in pa.get_functions()]\n            ['f()']\n        \"\"\"\n        return self.analysis_backend.get_all_functions(self.source_code)\n\n    def get_modules(self) -&gt; List[PyModule]:\n        \"\"\"Return all modules in the project directory.\n\n        Returns:\n            list[PyModule]: Modules discovered under project_dir.\n\n        Examples:\n            Create a temporary project and discover modules:\n\n            &gt;&gt;&gt; import os, tempfile\n            &gt;&gt;&gt; d = tempfile.mkdtemp()\n            &gt;&gt;&gt; _ = open(os.path.join(d, 'a.py'), 'w').write('print(1)')\n            &gt;&gt;&gt; _ = open(os.path.join(d, 'b.py'), 'w').write('print(2)')\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=d, source_code=None)\n            &gt;&gt;&gt; len(pa.get_modules()) &gt;= 2\n            True\n        \"\"\"\n        return self.analysis_backend.get_all_modules(self.project_dir)\n\n    def get_method_details(self, method_signature: str) -&gt; PyMethod:\n        \"\"\"Return details for a given method signature.\n\n        Args:\n            method_signature (str): Method signature to look up.\n\n        Returns:\n            PyMethod: Method details.\n\n        Examples:\n            &gt;&gt;&gt; src = 'class C: def add(self, a, b): return a+b'\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)  # doctest: +SKIP\n            &gt;&gt;&gt; pa.get_method_details('add(self, a, b)').full_signature  # doctest: +SKIP\n            'add(self, a, b)'\n        \"\"\"\n        return self.analysis_backend.get_method_details(self.source_code, method_signature)\n\n    def is_parsable(self, source_code: str) -&gt; bool:\n        \"\"\"Check if the source code is parsable.\n\n        Args:\n            source_code (str): Source code to parse.\n\n        Returns:\n            bool: True if parsable, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass')\n            True\n            &gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass if')\n            False\n        \"\"\"\n        return TreesitterPython().is_parsable(source_code)\n\n    def get_raw_ast(self, source_code: str) -&gt; str:\n        \"\"\"Parse and return the raw AST.\n\n        Args:\n            source_code (str): Source code to parse.\n\n        Returns:\n            str: Raw AST representation.\n\n        Examples:\n            &gt;&gt;&gt; ast = PythonAnalysis(None, None).get_raw_ast('def f(): pass')\n            &gt;&gt;&gt; isinstance(ast, str)\n            True\n        \"\"\"\n        return TreesitterPython().get_raw_ast(source_code)\n\n    def get_imports(self) -&gt; List[PyImport]:\n        \"\"\"Return all import statements.\n\n        Returns:\n            list[PyImport]: Imports discovered in the source code.\n\n        Examples:\n            &gt;&gt;&gt; src = 'import os; from math import sqrt; from x import *'\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n            &gt;&gt;&gt; len(pa.get_imports())\n            3\n        \"\"\"\n        return self.analysis_backend.get_all_imports_details(self.source_code)\n\n    def get_variables(self, **kwargs):\n        \"\"\"Return all variables discovered in the source code.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='x=1')\n            &gt;&gt;&gt; pa.get_variables()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_classes(self) -&gt; List[PyClass]:\n        \"\"\"Return all classes.\n\n        Returns:\n            list[PyClass]: Classes discovered in the source code.\n\n        Examples:\n            &gt;&gt;&gt; src = 'class A: pass'\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n            &gt;&gt;&gt; [c.class_name for c in pa.get_classes()]\n            ['A']\n        \"\"\"\n        return self.analysis_backend.get_all_classes(self.source_code)\n\n    def get_classes_by_criteria(self, **kwargs):\n        \"\"\"Return classes filtered by inclusion/exclusion criteria.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n            &gt;&gt;&gt; pa.get_classes_by_criteria()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_sub_classes(self, **kwargs):\n        \"\"\"Return all subclasses.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n            &gt;&gt;&gt; pa.get_sub_classes()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_nested_classes(self, **kwargs):\n        \"\"\"Return all nested classes.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: class B: pass')\n            &gt;&gt;&gt; pa.get_nested_classes()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_constructors(self, **kwargs):\n        \"\"\"Return all constructors.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def __init__(self): pass')\n            &gt;&gt;&gt; pa.get_constructors()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_methods_in_class(self, **kwargs):\n        \"\"\"Return all methods within a given class.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def f(self): pass')\n            &gt;&gt;&gt; pa.get_methods_in_class()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n\n    def get_fields(self, **kwargs):\n        \"\"\"Return all fields.\n\n        Raises:\n            NotImplementedError: This functionality is not implemented yet.\n\n        Examples:\n            &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: x=1')\n            &gt;&gt;&gt; pa.get_fields()  # doctest: +IGNORE_EXCEPTION_DETAIL\n            Traceback (most recent call last):\n            NotImplementedError: Support for this functionality has not been implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_methods","title":"<code>get_methods()</code>","text":"<p>Return all methods.</p> <p>Returns:</p> Type Description <code>List[PyMethod]</code> <p>list[PyMethod]: Methods discovered in the source code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'class C: def f(self): pass def g(self): pass'\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n&gt;&gt;&gt; len(pa.get_methods())\n2\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_methods(self) -&gt; List[PyMethod]:\n    \"\"\"Return all methods.\n\n    Returns:\n        list[PyMethod]: Methods discovered in the source code.\n\n    Examples:\n        &gt;&gt;&gt; src = 'class C: def f(self): pass def g(self): pass'\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)  # doctest: +SKIP\n        &gt;&gt;&gt; len(pa.get_methods())  # doctest: +SKIP\n        2\n    \"\"\"\n    return self.analysis_backend.get_all_methods(self.source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_functions","title":"<code>get_functions()</code>","text":"<p>Return all functions.</p> <p>Returns:</p> Type Description <code>List[PyMethod]</code> <p>list[PyMethod]: Functions discovered in the source code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'def f(): return 1'\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n&gt;&gt;&gt; [m.full_signature for m in pa.get_functions()]\n['f()']\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_functions(self) -&gt; List[PyMethod]:\n    \"\"\"Return all functions.\n\n    Returns:\n        list[PyMethod]: Functions discovered in the source code.\n\n    Examples:\n        &gt;&gt;&gt; src = 'def f(): return 1'\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n        &gt;&gt;&gt; [m.full_signature for m in pa.get_functions()]\n        ['f()']\n    \"\"\"\n    return self.analysis_backend.get_all_functions(self.source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_modules","title":"<code>get_modules()</code>","text":"<p>Return all modules in the project directory.</p> <p>Returns:</p> Type Description <code>List[PyModule]</code> <p>list[PyModule]: Modules discovered under project_dir.</p> <p>Examples:</p> <p>Create a temporary project and discover modules:</p> <pre><code>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; d = tempfile.mkdtemp()\n&gt;&gt;&gt; _ = open(os.path.join(d, 'a.py'), 'w').write('print(1)')\n&gt;&gt;&gt; _ = open(os.path.join(d, 'b.py'), 'w').write('print(2)')\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=d, source_code=None)\n&gt;&gt;&gt; len(pa.get_modules()) &gt;= 2\nTrue\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_modules(self) -&gt; List[PyModule]:\n    \"\"\"Return all modules in the project directory.\n\n    Returns:\n        list[PyModule]: Modules discovered under project_dir.\n\n    Examples:\n        Create a temporary project and discover modules:\n\n        &gt;&gt;&gt; import os, tempfile\n        &gt;&gt;&gt; d = tempfile.mkdtemp()\n        &gt;&gt;&gt; _ = open(os.path.join(d, 'a.py'), 'w').write('print(1)')\n        &gt;&gt;&gt; _ = open(os.path.join(d, 'b.py'), 'w').write('print(2)')\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=d, source_code=None)\n        &gt;&gt;&gt; len(pa.get_modules()) &gt;= 2\n        True\n    \"\"\"\n    return self.analysis_backend.get_all_modules(self.project_dir)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_method_details","title":"<code>get_method_details(method_signature)</code>","text":"<p>Return details for a given method signature.</p> <p>Parameters:</p> Name Type Description Default <code>method_signature</code> <code>str</code> <p>Method signature to look up.</p> required <p>Returns:</p> Name Type Description <code>PyMethod</code> <code>PyMethod</code> <p>Method details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'class C: def add(self, a, b): return a+b'\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n&gt;&gt;&gt; pa.get_method_details('add(self, a, b)').full_signature\n'add(self, a, b)'\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_method_details(self, method_signature: str) -&gt; PyMethod:\n    \"\"\"Return details for a given method signature.\n\n    Args:\n        method_signature (str): Method signature to look up.\n\n    Returns:\n        PyMethod: Method details.\n\n    Examples:\n        &gt;&gt;&gt; src = 'class C: def add(self, a, b): return a+b'\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)  # doctest: +SKIP\n        &gt;&gt;&gt; pa.get_method_details('add(self, a, b)').full_signature  # doctest: +SKIP\n        'add(self, a, b)'\n    \"\"\"\n    return self.analysis_backend.get_method_details(self.source_code, method_signature)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.is_parsable","title":"<code>is_parsable(source_code)</code>","text":"<p>Check if the source code is parsable.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to parse.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if parsable, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass')\nTrue\n&gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass if')\nFalse\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def is_parsable(self, source_code: str) -&gt; bool:\n    \"\"\"Check if the source code is parsable.\n\n    Args:\n        source_code (str): Source code to parse.\n\n    Returns:\n        bool: True if parsable, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass')\n        True\n        &gt;&gt;&gt; PythonAnalysis(None, None).is_parsable('def f(): pass if')\n        False\n    \"\"\"\n    return TreesitterPython().is_parsable(source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_raw_ast","title":"<code>get_raw_ast(source_code)</code>","text":"<p>Parse and return the raw AST.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to parse.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Raw AST representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ast = PythonAnalysis(None, None).get_raw_ast('def f(): pass')\n&gt;&gt;&gt; isinstance(ast, str)\nTrue\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_raw_ast(self, source_code: str) -&gt; str:\n    \"\"\"Parse and return the raw AST.\n\n    Args:\n        source_code (str): Source code to parse.\n\n    Returns:\n        str: Raw AST representation.\n\n    Examples:\n        &gt;&gt;&gt; ast = PythonAnalysis(None, None).get_raw_ast('def f(): pass')\n        &gt;&gt;&gt; isinstance(ast, str)\n        True\n    \"\"\"\n    return TreesitterPython().get_raw_ast(source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_imports","title":"<code>get_imports()</code>","text":"<p>Return all import statements.</p> <p>Returns:</p> Type Description <code>List[PyImport]</code> <p>list[PyImport]: Imports discovered in the source code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'import os; from math import sqrt; from x import *'\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n&gt;&gt;&gt; len(pa.get_imports())\n3\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_imports(self) -&gt; List[PyImport]:\n    \"\"\"Return all import statements.\n\n    Returns:\n        list[PyImport]: Imports discovered in the source code.\n\n    Examples:\n        &gt;&gt;&gt; src = 'import os; from math import sqrt; from x import *'\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n        &gt;&gt;&gt; len(pa.get_imports())\n        3\n    \"\"\"\n    return self.analysis_backend.get_all_imports_details(self.source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_variables","title":"<code>get_variables(**kwargs)</code>","text":"<p>Return all variables discovered in the source code.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='x=1')\n&gt;&gt;&gt; pa.get_variables()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_variables(self, **kwargs):\n    \"\"\"Return all variables discovered in the source code.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='x=1')\n        &gt;&gt;&gt; pa.get_variables()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_classes","title":"<code>get_classes()</code>","text":"<p>Return all classes.</p> <p>Returns:</p> Type Description <code>List[PyClass]</code> <p>list[PyClass]: Classes discovered in the source code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = 'class A: pass'\n&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n&gt;&gt;&gt; [c.class_name for c in pa.get_classes()]\n['A']\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_classes(self) -&gt; List[PyClass]:\n    \"\"\"Return all classes.\n\n    Returns:\n        list[PyClass]: Classes discovered in the source code.\n\n    Examples:\n        &gt;&gt;&gt; src = 'class A: pass'\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code=src)\n        &gt;&gt;&gt; [c.class_name for c in pa.get_classes()]\n        ['A']\n    \"\"\"\n    return self.analysis_backend.get_all_classes(self.source_code)\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_classes_by_criteria","title":"<code>get_classes_by_criteria(**kwargs)</code>","text":"<p>Return classes filtered by inclusion/exclusion criteria.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n&gt;&gt;&gt; pa.get_classes_by_criteria()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_classes_by_criteria(self, **kwargs):\n    \"\"\"Return classes filtered by inclusion/exclusion criteria.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n        &gt;&gt;&gt; pa.get_classes_by_criteria()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_sub_classes","title":"<code>get_sub_classes(**kwargs)</code>","text":"<p>Return all subclasses.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n&gt;&gt;&gt; pa.get_sub_classes()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_sub_classes(self, **kwargs):\n    \"\"\"Return all subclasses.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: pass')\n        &gt;&gt;&gt; pa.get_sub_classes()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_nested_classes","title":"<code>get_nested_classes(**kwargs)</code>","text":"<p>Return all nested classes.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: class B: pass')\n&gt;&gt;&gt; pa.get_nested_classes()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_nested_classes(self, **kwargs):\n    \"\"\"Return all nested classes.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: class B: pass')\n        &gt;&gt;&gt; pa.get_nested_classes()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_constructors","title":"<code>get_constructors(**kwargs)</code>","text":"<p>Return all constructors.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def __init__(self): pass')\n&gt;&gt;&gt; pa.get_constructors()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_constructors(self, **kwargs):\n    \"\"\"Return all constructors.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def __init__(self): pass')\n        &gt;&gt;&gt; pa.get_constructors()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_methods_in_class","title":"<code>get_methods_in_class(**kwargs)</code>","text":"<p>Return all methods within a given class.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def f(self): pass')\n&gt;&gt;&gt; pa.get_methods_in_class()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_methods_in_class(self, **kwargs):\n    \"\"\"Return all methods within a given class.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: def f(self): pass')\n        &gt;&gt;&gt; pa.get_methods_in_class()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#cldk.analysis.python.python_analysis.PythonAnalysis.get_fields","title":"<code>get_fields(**kwargs)</code>","text":"<p>Return all fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This functionality is not implemented yet.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: x=1')\n&gt;&gt;&gt; pa.get_fields()\nTraceback (most recent call last):\nNotImplementedError: Support for this functionality has not been implemented yet.\n</code></pre> Source code in <code>cldk/analysis/python/python_analysis.py</code> <pre><code>def get_fields(self, **kwargs):\n    \"\"\"Return all fields.\n\n    Raises:\n        NotImplementedError: This functionality is not implemented yet.\n\n    Examples:\n        &gt;&gt;&gt; pa = PythonAnalysis(project_dir=None, source_code='class A: x=1')\n        &gt;&gt;&gt; pa.get_fields()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        NotImplementedError: Support for this functionality has not been implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"Support for this functionality has not been implemented yet.\")\n</code></pre>"},{"location":"reference/python-api/python/#schema","title":"Schema","text":"<p>Data models used by the Python analyzers.</p> <p>Models module</p>"},{"location":"reference/python-api/python/#cldk.models.python.models.PyBuildAttributes","title":"<code>PyBuildAttributes</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Handles all the project build tool (requirements.txt/poetry/setup.py) attributes</p> Source code in <code>cldk/models/python/models.py</code> <pre><code>class PyBuildAttributes(BaseModel):\n    \"\"\"Handles all the project build tool (requirements.txt/poetry/setup.py) attributes\"\"\"\n</code></pre>"},{"location":"reference/python-api/python/#cldk.models.python.models.PyConfig","title":"<code>PyConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration information</p> Source code in <code>cldk/models/python/models.py</code> <pre><code>class PyConfig(BaseModel):\n    \"\"\"Application configuration information\"\"\"\n</code></pre>"},{"location":"reference/ts-api/","title":"Typescript API Reference","text":""},{"location":"reference/ts-api/#overview","title":"Overview","text":"<p>Browse the CLDK's Typescript API reference. Use the links below to view package-specific documentation.</p> <p>(work in progress, please checkback later or email authors)</p>"}]}